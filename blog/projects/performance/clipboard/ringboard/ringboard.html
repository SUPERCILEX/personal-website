<!doctype html><html class=min-height-full lang=en><meta charset=utf-8><meta content="width=device-width,initial-scale=1,shrink-to-fit=no" name=viewport><meta content="light dark" name=color-scheme><link href=/favicon.ico rel=icon type=image/x-icon><link href=//fonts.gstatic.com/s/atkinsonhyperlegible/v10/9Bt23C1KxNDXMspQ1lPyU89-1h6ONRlW45G04pIo.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/feed.xml rel=alternate type=application/atom+xml title="Alex Saveau"><title>Ringboard: the infinitely scalable clipboard manager for Linux | Alex Saveau</title><meta content="Jekyll v4.3.2" name=generator><meta content="Ringboard: the infinitely scalable clipboard manager for Linux" property=og:title><meta content="Alex Saveau" name=author><meta content=en_US property=og:locale><meta content="Ringboard is a simple yet powerful clipboard manager, designed for Linux to be desktop environment (DE) agnostic. Ringboard strives to be as efficient as possible, use a minimal constant amount of memory, scale to massive clipboards, and be composable with the rest of the ecosystem. It is implemented using a client-server architecture (with a Unix Domain Socket) which enables using a command line interface (CLI) for lower level operations, a terminal user interface (TUI) for a convenient yet unobtrusive interface, and various graphical user interfaces (GUIs). Currently, the clients include a stand-alone GUI implemented using egui and a TUI implemented using ratatui with plans for a COSMIC applet (issue) and Gnome extension (issue). Ringboard aims to be the best clipboard manager for Linux." name=description><meta content="Ringboard is a simple yet powerful clipboard manager, designed for Linux to be desktop environment (DE) agnostic. Ringboard strives to be as efficient as possible, use a minimal constant amount of memory, scale to massive clipboards, and be composable with the rest of the ecosystem. It is implemented using a client-server architecture (with a Unix Domain Socket) which enables using a command line interface (CLI) for lower level operations, a terminal user interface (TUI) for a convenient yet unobtrusive interface, and various graphical user interfaces (GUIs). Currently, the clients include a stand-alone GUI implemented using egui and a TUI implemented using ratatui with plans for a COSMIC applet (issue) and Gnome extension (issue). Ringboard aims to be the best clipboard manager for Linux." property=og:description><link href=https://alexsaveau.dev/blog/projects/performance/clipboard/ringboard/ringboard rel=canonical><meta content=https://alexsaveau.dev/blog/projects/performance/clipboard/ringboard/ringboard property=og:url><meta content="Alex Saveau" property=og:site_name><meta content=https://alexsaveau.dev/assets/resized/projects/ringboard/demo-800-min.jpg property=og:image><meta content=article property=og:type><meta content=2024-07-21T00:00:00+00:00 property=article:published_time><meta content=summary_large_image name=twitter:card><meta content=https://alexsaveau.dev/assets/resized/projects/ringboard/demo-800-min.jpg property=twitter:image><meta content="Ringboard: the infinitely scalable clipboard manager for Linux" property=twitter:title><meta content=@SUPERCILEX name=twitter:site><meta content=@SUPERCILEX name=twitter:creator><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Alex Saveau"},"dateModified":"2025-09-22T01:35:53+00:00","datePublished":"2024-07-21T00:00:00+00:00","description":"Ringboard is a simple yet powerful clipboard manager, designed for Linux to be desktop environment (DE) agnostic. Ringboard strives to be as efficient as possible, use a minimal constant amount of memory, scale to massive clipboards, and be composable with the rest of the ecosystem. It is implemented using a client-server architecture (with a Unix Domain Socket) which enables using a command line interface (CLI) for lower level operations, a terminal user interface (TUI) for a convenient yet unobtrusive interface, and various graphical user interfaces (GUIs). Currently, the clients include a stand-alone GUI implemented using egui and a TUI implemented using ratatui with plans for a COSMIC applet (issue) and Gnome extension (issue). Ringboard aims to be the best clipboard manager for Linux.","headline":"Ringboard: the infinitely scalable clipboard manager for Linux","image":"https://alexsaveau.dev/assets/resized/projects/ringboard/demo-800-min.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"https://alexsaveau.dev/blog/projects/performance/clipboard/ringboard/ringboard"},"url":"https://alexsaveau.dev/blog/projects/performance/clipboard/ringboard/ringboard"}</script><script>window.addEventListener("DOMContentLoaded",()=>{for(let e of document.querySelectorAll(".loads")){var o=()=>{e.classList.remove("loads")};e.complete?o():(e.onload=o,e.onerror=o)}})</script><noscript><style>.loads{animation:none!important;background-color:unset!important}</style></noscript><link href=//fonts.gstatic.com/s/firacode/v17/uU9NCBsR6Z2vfE9aq3bh3dSD.woff2 rel=preload type=font/woff2 as=font crossorigin><style>@keyframes tooltip-appear{0%{opacity:0}to{opacity:1}}@keyframes pulse{0%,to{opacity:1}50%{opacity:.33}}:root{--progress-color:gray;--blockquote-color:#6a737d;--blockquote-boarder-color:#959da5;--code-background-color:rgba(0, 0, 0, 0.05);--hr-color:gray;--footer-color:white;--loading-pulse-color:#b0b0b0}@font-face{font-family:"Fira Code";font-style:normal;font-weight:475;font-display:swap;src:url(//fonts.gstatic.com/s/firacode/v17/uU9NCBsR6Z2vfE9aq3bh3dSD.woff2) format("woff2");unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}.article{overflow-wrap:break-word}.article .highlight{background-color:rgba(0,0,0,.04);border-radius:3px}.article .caption{font-size:1rem;margin:-1.5em 0 0}.article h2,.article h3,.article h4{margin:1.5em 0-.5em}.article h2{font-size:1.875rem}.article h3{font-size:1.5rem}.article h3 code,.article h4{font-size:1.25rem}.article p{font-size:1.313rem;margin:.95em 0 1.2em}.article p.caption{text-align:center}.article img.article-image{width:100%;height:auto}.article code{font-family:"Fira Code",monospace;font-size:1rem;background-color:var(--code-background-color);border-radius:3px;padding:2px 4px}.article blockquote{border-left:4px solid var(--blockquote-boarder-color);padding-left:16px;margin-bottom:16px;margin-left:0;margin-right:0}.article blockquote :not(a){color:var(--blockquote-color)}.article div pre{padding:20px}.article div pre code,a{background-color:transparent}.article div pre code{padding:0}.article li ul,.article ul{font-size:1.313rem;padding-left:32px;margin-bottom:16px}.article li ul{padding-left:16px;margin-bottom:0}.header-link{visibility:hidden}h2:hover .header-link,h3:hover .header-link,h4:hover .header-link{visibility:visible}@media (prefers-color-scheme:dark){:root{--progress-color:whitesmoke;--blockquote-color:#dadada;--blockquote-boarder-color:#dadada;--code-background-color:rgba(255,255,255,0.15)}.article .caption{color:#dadada}.article p{color:#ededed}.article img:not([src*=".svg"]){filter:brightness(.8) contrast(1.1)}}.octicon{display:inline-block;fill:currentColor;vertical-align:text-bottom}html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji";line-height:1.5;color:#24292e;background-color:#fff;font-family:Atkinson Hyperlegible,sans-serif;font-size:1em}footer{display:block;display:flex;padding:5px;align-items:center;background-color:var(--footer-color)}a{color:#0366d6;text-decoration:none}a:active,a:hover{outline-width:0}h1{margin:.67em 0}small{font-size:90%}sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline;top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}*{box-sizing:border-box}a:hover{text-decoration:underline}kbd{display:inline-block;padding:3px 5px;color:#444d56;vertical-align:middle;background-color:#fafbfc;border:1px solid #d1d5da;border-bottom-color:#d1d5da;border-radius:6px;box-shadow:inset 0-1px 0#d1d5da;font-size:.525em;line-height:.9em}h1,h2,h3,h4,p,pre,ul{margin-top:0;margin-bottom:0}h1,h2,h3,h4{font-size:2rem;font-weight:600}h2,h3,h4{font-size:1.5rem}h3,h4{font-size:1.25rem}h4{font-size:1rem}p{margin-bottom:10px}blockquote{margin:0}ul{padding-left:0}code,pre{font-family:SFMono-Regular,Consolas,"Liberation Mono",Menlo,monospace;font-size:.75rem}:-ms-input-placeholder{color:#6a737d;opacity:1}::-ms-input-placeholder{color:#6a737d;opacity:1}:checked+.radio-label{position:relative;z-index:1;border-color:#0366d6}@media (min-width:768px){.col-md-5{width:41.66667%}.col-md-7{width:58.33333%}}@media (min-width:1012px){.col-lg-4{width:33.33333%}.col-lg-8{width:66.66667%}}@media (min-width:1280px){.col-xl-3{width:25%}.col-xl-9{width:75%}}.tooltipped{position:relative}.tooltipped::after,.tooltipped::before{position:absolute;display:none;pointer-events:none;opacity:0}.tooltipped::after{z-index:1000000;padding:.5em .75em;font:11px/1.5 -apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji";-webkit-font-smoothing:subpixel-antialiased;color:#fff;text-align:center;text-decoration:none;text-shadow:none;text-transform:none;letter-spacing:normal;word-wrap:break-word;white-space:pre;content:attr(aria-label);background:#1b1f23;border-radius:6px}.tooltipped::before{z-index:1000001;width:0;height:0;color:#1b1f23;content:"";border:6px solid transparent}.tooltipped:active::after,.tooltipped:active::before,.tooltipped:focus::after,.tooltipped:focus::before,.tooltipped:hover::after,.tooltipped:hover::before{display:inline-block;text-decoration:none;animation-name:tooltip-appear;animation-duration:.1s;animation-fill-mode:forwards;animation-timing-function:ease-in;animation-delay:.4s}.tooltipped-se::after{top:100%;margin-top:6px}.tooltipped-se::before{top:auto;right:50%;bottom:-7px;margin-right:-6px;border-bottom-color:#1b1f23}.tooltipped-se::after{right:auto;left:50%;margin-left:-16px}.border-top{border-top:1px solid #e1e4e8!important}@media (min-width:768px){.border-md-right{border-right:1px solid #e1e4e8!important}.border-md-bottom{border-bottom:1px solid #e1e4e8!important}.border-md-top-0{border-top:0!important}}.circle{border-radius:50%!important}.border-gray-light{border-color:#eaecef!important}.bg-white{background-color:#fff!important}.bg-gray-light{background-color:#fafbfc!important}.text-gray{color:#586069!important}.flex-wrap{flex-wrap:wrap!important}.flex-items-start{align-items:flex-start!important}.flex-items-center{align-items:center!important}.flex-self-stretch{align-self:stretch!important}.v-align-middle{vertical-align:middle!important}.mr-2{margin-right:8px!important}.mx-auto{margin-right:auto!important;margin-left:auto!important}.px-4{padding-right:24px!important;padding-left:24px!important}.f4{font-size:1rem!important}@media (min-width:768px){.px-md-6{padding-right:40px!important;padding-left:40px!important}.f4{font-size:1rem!important}}.f5{font-size:.875rem!important}.f00-light{font-size:2.5rem!important;font-weight:300!important}@media (min-width:768px){.f00-light{font-size:3rem!important}}.f2-light{font-size:1.375rem!important;font-weight:300!important}.lh-condensed{line-height:1.25!important}.d-flex{display:flex!important}.d-none{display:none!important}@font-face{font-family:Inter;font-style:normal;font-weight:400;src:local("Inter"),local("Inter-Regular"),url(/fonts/Inter-Regular.woff) format("woff");font-display:swap}@font-face{font-family:Inter;font-style:normal;font-weight:500;src:local("Inter Medium"),local("Inter-Medium"),url(/fonts/Inter-Medium.woff) format("woff");font-display:swap}@font-face{font-family:Inter;font-style:normal;font-weight:600;src:local("Inter Bold"),local("Inter-Bold"),url(/fonts/Inter-Bold.woff) format("woff");font-display:swap}.mb-2{margin-bottom:8px!important}.mb-3{margin-bottom:16px!important}.mb-5{margin-bottom:32px!important}.mb-6{margin-bottom:40px!important}.py-6{padding-top:40px!important;padding-bottom:40px!important}.highlight{width:100%;overflow:auto;background:#fff}.highlight .k,.highlight .o{font-weight:700}.highlight .c1{color:#998;font-style:italic}.highlight .nb{color:#0086b3}.highlight .nf{color:#900;font-weight:700}@font-face{font-family:"Atkinson Hyperlegible";font-style:normal;font-weight:400;font-display:swap;src:url(//fonts.gstatic.com/s/atkinsonhyperlegible/v10/9Bt23C1KxNDXMspQ1lPyU89-1h6ONRlW45G04pIo.woff2) format("woff2");unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}footer small{width:100%}footer small:last-child{text-align:end}.min-height-full{min-height:100vh}.icon-color{fill:#24292e!important}.loads{animation-duration:2s;animation:2s cubic-bezier(.4,0,.6,1) infinite pulse;animation-timing-function:cubic-bezier(.4,0,.6,1);animation-iteration-count:infinite;animation-name:pulse;background-color:var(--loading-pulse-color)}@media (min-width:768px){.f2-light{font-size:1.5rem!important}.d-md-flex{display:flex!important}#masthead{position:fixed;width:min-content}.masthead-name-mobile{display:none}}@media (max-width:768px){.masthead-mini{padding-top:10px!important;padding-bottom:10px!important}.masthead-mini-container{display:flex;align-items:center}.masthead-profile{width:80px;height:80px;margin-bottom:0!important}.masthead-intro{padding-left:24px}.masthead-name{display:none}.masthead-bio{margin-bottom:0!important}.masthead-metadata{display:none}}@media (min-width:1942px){.masthead{max-width:400px}.content-container{width:100%}}@media (prefers-color-scheme:dark){.highlight pre{background-color:#272822}.highlight .k{color:#66d9ef}.highlight .n{color:#f8f8f2}.highlight .o{color:#f92672}.highlight .p{color:#f8f8f2}.highlight .c1{color:#b4aa77}.highlight .nb{color:#f8f8f2}.highlight .nd,.highlight .nf{color:#a6e22e}:root{--hr-color:whitesmoke;--footer-color:black;--loading-pulse-color:#383838}a{color:unset!important;text-decoration:underline}.bg-white{background-color:#4f565d!important}.bg-gray-light{background-color:#2f363d!important}.border-gray-light{border-color:transparent!important}.text-gray{color:#d0d8e1!important}.border-md-bottom{border:0!important}.masthead{background-color:#24292e!important}.scoped-text-defaults,.text-defaults,.text-defaults *{color:#fff!important}.icon-color{fill:#fff!important}}</style><body class=min-height-full id=top><div class="min-height-full bg-gray-light border-md-bottom d-md-flex"><div class="px-4 px-lg-7 py-6 bg-white border-gray-light border-md-right col-lg-4 col-md-5 col-xl-3 flex-self-stretch masthead masthead-mini px-md-6"><div class=masthead-mini-container id=masthead><a href=/ ><picture><source sizes=150px srcset="/assets/resized/me2-240-min.avif 240w, /assets/resized/me2-320-min.avif 320w, /assets/resized/me2-480-min.avif 480w, /assets/resized/me2-800-min.avif 800w, /assets/resized/me2-min.avif 1528w" type=image/avif><source sizes=150px srcset="/assets/resized/me2-240-min.webp 240w, /assets/resized/me2-320-min.webp 320w, /assets/resized/me2-480-min.webp 480w, /assets/resized/me2-800-min.webp 800w, /assets/resized/me2-min.webp 1528w" type=image/webp><source sizes=150px srcset="/assets/resized/me2-240-min.jpg 240w, /assets/resized/me2-320-min.jpg 320w, /assets/resized/me2-480-min.jpg 480w, /assets/resized/me2-800-min.jpg 800w, /assets/resized/me2-min.jpg 1528w" type=image/jpeg><source sizes=150px srcset="/assets/resized/me2-240.jpg 240w, /assets/resized/me2-320.jpg 320w, /assets/resized/me2-480.jpg 480w, /assets/resized/me2-800.jpg 800w, /assets/me2.jpg 1528w"><img alt="Profile Picture" class="mb-3 circle loads masthead-profile" height=150 loading=lazy src=/assets/resized/me2-240.jpg width=150></picture></a><div class=masthead-intro><h1 class="text-defaults lh-condensed mb-2 masthead-name">Alex Saveau</h1><h2 class="text-defaults lh-condensed mb-2 masthead-name-mobile">Alex Saveau</h2><p class="mb-3 f4 masthead-bio text-gray" id=bio>Relentless efficiency</div><div class="f4 masthead-metadata"><div class="text-defaults d-flex flex-items-center mb-3"><svg height=20 viewBox="0 0 16 16" aria-label=GitHub class="icon-color mr-2 octicon v-align-middle octicon-mark-github" role=img version=1.1 width=20><path d="M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z"></path></svg> <a href=//github.com/SUPERCILEX>@SUPERCILEX</a></div><div class="text-defaults d-flex flex-items-center mb-3"><svg height=20 viewBox="0 0 16 16" aria-label=email class="icon-color mr-2 octicon v-align-middle octicon-mail" role=img version=1.1 width=20><path d="M1.75 2h12.5c.966 0 1.75.784 1.75 1.75v8.5A1.75 1.75 0 0 1 14.25 14H1.75A1.75 1.75 0 0 1 0 12.25v-8.5C0 2.784.784 2 1.75 2ZM1.5 12.251c0 .138.112.25.25.25h12.5a.25.25 0 0 0 .25-.25V5.809L8.38 9.397a.75.75 0 0 1-.76 0L1.5 5.809v6.442Zm13-8.181v-.32a.25.25 0 0 0-.25-.25H1.75a.25.25 0 0 0-.25.25v.32L8 7.88Z"></path></svg> <a href=mailto:saveau.alexandre@gmail.com>saveau.alexandre@gmail.com</a></div><div class="flex-items-start d-flex flex-wrap"><div class=mb-3><a href=//stackoverflow.com/u/4548500 class="tooltipped tooltipped-se" aria-label="Stack Overflow: 4548500"><svg height=24 viewBox="0 0 120 120" fill=#959da5 xmlns=http://www.w3.org/2000/svg><path d="M84.4 93.8V70.6h7.7v30.9H22.6V70.6h7.7v23.2z" class=st0 /><path d="M38.8 68.4l37.8 7.9 1.6-7.6-37.8-7.9-1.6 7.6zm5-18l35 16.3 3.2-7-35-16.4-3.2 7.1zm9.7-17.2l29.7 24.7 4.9-5.9-29.7-24.7-4.9 5.9zm19.2-18.3l-6.2 4.6 23 31 6.2-4.6-23-31zM38 86h38.6v-7.7H38V86z" class=st1 /></svg><span class=d-none>Stack Overflow</span></a></div></div></div></div></div><div class="px-4 px-lg-7 py-6 border-md-top-0 border-top col-lg-8 col-md-7 col-xl-9 content-container" id=article><div class=mx-auto style=max-width:900px><div class="f4 mb-6"><div class="f4 scoped-text-defaults"><p class=f5><a href=/blog class="text-defaults d-flex flex-items-center"><svg height=16 viewBox="0 0 16 16" aria-label=include.parent class="icon-color mr-2 octicon v-align-middle octicon-chevron-left" role=img version=1.1 width=16><path d="M9.78 12.78a.75.75 0 0 1-1.06 0L4.47 8.53a.75.75 0 0 1 0-1.06l4.25-4.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042L6.06 8l3.72 3.72a.75.75 0 0 1 0 1.06Z"></path></svg>Blog</a><h1 class="text-defaults lh-condensed f00-light" style=font-weight:600!important>Ringboard: the infinitely scalable clipboard manager for Linux</h1><h2 class="lh-condensed f2-light text-gray" style=font-weight:400!important>Technical overview of a high-performance multi-arena ring allocator database</h2><p class="text-gray mb-5">Published Jul 21, 2024 • Last updated Sep 22, 2025 • 28 min read<div class=article><p><a href=/assets/projects/ringboard/demo.png><picture><source sizes="(min-width: 768px) 85vw, 100vw" srcset="/assets/resized/projects/ringboard/demo-240-min.avif 240w, /assets/resized/projects/ringboard/demo-320-min.avif 320w, /assets/resized/projects/ringboard/demo-480-min.avif 480w, /assets/resized/projects/ringboard/demo-800-min.avif 800w, /assets/resized/projects/ringboard/demo-1600-min.avif 1600w, /assets/resized/projects/ringboard/demo-3200-min.avif 3200w, /assets/resized/projects/ringboard/demo-min.avif 3840w" type=image/avif><source sizes="(min-width: 768px) 85vw, 100vw" srcset="/assets/resized/projects/ringboard/demo-240-min.webp 240w, /assets/resized/projects/ringboard/demo-320-min.webp 320w, /assets/resized/projects/ringboard/demo-480-min.webp 480w, /assets/resized/projects/ringboard/demo-800-min.webp 800w, /assets/resized/projects/ringboard/demo-1600-min.webp 1600w, /assets/resized/projects/ringboard/demo-3200-min.webp 3200w, /assets/resized/projects/ringboard/demo-min.webp 3840w" type=image/webp><source sizes="(min-width: 768px) 85vw, 100vw" srcset="/assets/resized/projects/ringboard/demo-240-min.jpg 240w, /assets/resized/projects/ringboard/demo-320-min.jpg 320w, /assets/resized/projects/ringboard/demo-480-min.jpg 480w, /assets/resized/projects/ringboard/demo-800-min.jpg 800w, /assets/resized/projects/ringboard/demo-1600-min.jpg 1600w, /assets/resized/projects/ringboard/demo-3200-min.jpg 3200w, /assets/resized/projects/ringboard/demo-min.jpg 3840w" type=image/jpeg><source sizes="(min-width: 768px) 85vw, 100vw" srcset="/assets/resized/projects/ringboard/demo-240.png 240w, /assets/resized/projects/ringboard/demo-320.png 320w, /assets/resized/projects/ringboard/demo-480.png 480w, /assets/resized/projects/ringboard/demo-800.png 800w, /assets/resized/projects/ringboard/demo-1600.png 1600w, /assets/resized/projects/ringboard/demo-3200.png 3200w, /assets/projects/ringboard/demo.png 3840w"><img alt="A screenshot demo-ing the various clients." class="article-image loads" height=2400 loading=lazy src=/assets/resized/projects/ringboard/demo-240.png width=3840></picture></a><div class=text-gray><p class=caption>Ringboard TUI on the left, Ringboard CLI and GUI on the right (top and bottom respectively).</div><br><p><a href=//github.com/SUPERCILEX/clipboard-history>Ringboard</a> is a simple yet powerful clipboard manager, designed for Linux to be desktop environment (DE) agnostic. Ringboard strives to be as efficient as possible, use a minimal constant amount of memory, scale to massive clipboards, and be composable with the rest of the ecosystem. It is implemented using a client-server architecture (with a <a href=//man7.org/linux/man-pages/man7/unix.7.html>Unix Domain Socket</a>) which enables using a command line interface (CLI) for lower level operations, a terminal user interface (TUI) for a convenient yet unobtrusive interface, and various graphical user interfaces (GUIs). Currently, the clients include a stand-alone GUI implemented using <a href=//github.com/emilk/egui>egui</a> and a TUI implemented using <a href=//github.com/ratatui-org/ratatui>ratatui</a> with plans for a <a href=//github.com/pop-os/cosmic-epoch>COSMIC</a> applet (<a href=//github.com/SUPERCILEX/clipboard-history/issues/11>issue</a>) and <a href=//extensions.gnome.org/about/ >Gnome extension</a> (<a href=//github.com/SUPERCILEX/clipboard-history/issues/16>issue</a>). Ringboard aims to be the best clipboard manager for Linux.<ul id=markdown-toc><li><a href=#introduction id=markdown-toc-introduction>Introduction</a><li><a href=#background id=markdown-toc-background>Background</a><li><a href=#system-architecture id=markdown-toc-system-architecture>System architecture</a><ul><li><a href=#the-ring id=markdown-toc-the-ring>The ring</a><ul><li><a href=#ring-entries id=markdown-toc-ring-entries>Ring entries</a></ul><li><a href=#the-data-store id=markdown-toc-the-data-store>The data store</a><li><a href=#directory-structure id=markdown-toc-directory-structure>Directory structure</a></ul><li><a href=#the-server id=markdown-toc-the-server>The server</a><ul><li><a href=#protocol id=markdown-toc-protocol>Protocol</a><li><a href=#recovering-from-unexpected-shutdowns id=markdown-toc-recovering-from-unexpected-shutdowns>Recovering from unexpected shutdowns</a><li><a href=#rings-rings-everywhere id=markdown-toc-rings-rings-everywhere>Rings, rings everywhere</a><li><a href=#a-note-on-mmap-semantics id=markdown-toc-a-note-on-mmap-semantics>A note on <code class="highlighter-rouge language-plaintext">mmap</code> semantics</a></ul><li><a href=#clients id=markdown-toc-clients>Clients</a><ul><li><a href=#receiving-copied-items-via-wayland-or-x11 id=markdown-toc-receiving-copied-items-via-wayland-or-x11>Receiving copied items via Wayland or X11</a><ul><li><a href=#an-aside-on-the-nature-of-clipboards-which-mime-type-to-use id=markdown-toc-an-aside-on-the-nature-of-clipboards-which-mime-type-to-use>An aside on the nature of clipboards: which mime type to use?</a></ul><li><a href=#pasting-items id=markdown-toc-pasting-items>Pasting items</a><li><a href=#gui-startup-latency-and-long-lived-client-windows id=markdown-toc-gui-startup-latency-and-long-lived-client-windows>GUI startup latency and long-lived client windows</a></ul><li><a href=#advanced-features id=markdown-toc-advanced-features>Advanced features</a><ul><li><a href=#search id=markdown-toc-search>Search</a><li><a href=#garbage-collection id=markdown-toc-garbage-collection>Garbage collection</a><li><a href=#ring-resizing id=markdown-toc-ring-resizing>Ring resizing</a></ul><li><a href=#flaws id=markdown-toc-flaws>Flaws</a><ul><li><a href=#blocking-reads id=markdown-toc-blocking-reads>Blocking reads</a><li><a href=#database-reliability id=markdown-toc-database-reliability>Database reliability</a><ul><li><a href=#local-corruption id=markdown-toc-local-corruption>Local corruption</a><li><a href=#raciness id=markdown-toc-raciness>Raciness</a></ul><li><a href=#error-handling-and-malicious-actors id=markdown-toc-error-handling-and-malicious-actors>Error handling and malicious actors</a><li><a href=#complexity id=markdown-toc-complexity>Complexity</a></ul><li><a href=#random-whining id=markdown-toc-random-whining>Random whining</a><ul><li><a href=#writing-fast-and-maintainable-code-is-still-stinkin-impossible id=markdown-toc-writing-fast-and-maintainable-code-is-still-stinkin-impossible>Writing fast <em>and</em> maintainable code is still stinkin’ impossible</a><li><a href=#error-handling-still-sucks-especially-in-guis id=markdown-toc-error-handling-still-sucks-especially-in-guis>Error handling still sucks, especially in GUIs</a><li><a href=#writing-guis-that-spark-joy-is-a-pain-especially-in-rust id=markdown-toc-writing-guis-that-spark-joy-is-a-pain-especially-in-rust>Writing GUIs that spark joy is a pain, especially in Rust</a></ul><li><a href=#conclusion id=markdown-toc-conclusion>Conclusion</a></ul><h2 id=introduction>Introduction <a href=#introduction class=header-link>#</a></h2><p>Ringboard supports copying arbitrary data—that includes images, PowerPoint slides, or anything else you might conceive of. In fact, Ringboard is a byte-oriented database masquerading as a clipboard manager. The core technology is founded upon the following axioms:<ul><li>Data is (mostly) append-only.<li>The primary operation is insert.<li>Old entries may be deleted transparently.<li>There is an arbitrary upper bound on the number of entries.</ul><p>These axioms lead to the theorem driving Ringboard’s technical decisions: the number of entries stored in Ringboard approaches the maximum entry count as a user uses the clipboard. An important corollary is that insertion also requires deletion with high probability. Therefore, Ringboard is implemented as a disk-backed ring allocator with the freedom to delete old data whenever the allocator runs out of space.<p>As you will see, Ringboard scales “infinitely” in the sense that we never need to hold the entirety of the database in memory at once, so we are limited only by disk storage space. In practice, Ringboard holds almost none of the database in memory, using just a few hundred KiBs of memory. Only reading the necessary parts of the database makes both client and server startup times extremely fast—less than 50ms in my benchmarks. In brief, Ringboard can effortlessly handle millions of entries.<p>To be fair, none of this is particularly impressive from the perspective of a database implementer. However, in the world of clipboard managers where data is usually stored as a single JSON/XML file or not at all, this design is comparatively advanced. As noted earlier, there is a key domain specific property Ringboard takes advantage of that makes it more efficient than any general purpose database: data can be deleted transparently.<h2 id=background>Background <a href=#background class=header-link>#</a></h2><p>Ringboard has ancestral roots in my <a href=../gnome/gch/gnome-clipboard-history>Gnome Clipboard History</a> (GCH) extension which was implemented as an append-only log. GCH’s log is unfortunately not <a href=//en.wikipedia.org/wiki/Self-synchronizing_code>self-synchronizing</a> as there are back pointers with arbitrary locations, meaning you have to read the entire log and apply operations sequentially in order to accurately reconstruct the database.<p>Since I was finally able to use Rust for this next generation clipboard manager, I wanted to find a way to use the <a href=//man7.org/linux/man-pages/man2/mmap.2.html>mmap syscall</a> such that I could both have the entirety of the clipboard database available through memory accesses while also not requiring that data to be held in volatile memory. In other words, Ringboard lives with the illusion that the entire database is in memory while in reality only a few pages’ worth of it are—turns out you can have your cake and eat it too!<p>The key idea improving upon GCH was to split metadata and data so that each entry’s metadata is a fixed size. This and other insights leading to the final design described in this article are available <a href=//github.com/SUPERCILEX/clipboard-history/issues/3>here</a>.<h2 id=system-architecture>System architecture <a href=#system-architecture class=header-link>#</a></h2><p>Ringboard supports two kinds of clipboard entries: normal and favorites. Favorited entries are always visible and should stick around even if we need to start deleting normal entries. Thus, Ringboard is really <code class="highlighter-rouge language-plaintext">N</code> ring allocators with a shared backing store. While the full generalization hasn’t been implemented, this architecture enables the possibility of tagging entries (each tag is its own ring). Currently, <code class="highlighter-rouge language-plaintext">N=2</code> is hardcoded to support the normal ring and the favorites ring.<p>Each ring holds the metadata for its entries. The backing data store is shared between rings and consists of a file per entry for large entries or a slot from an arena allocation for small entries. A diagram will hopefully be easier to understand:<div style=background-color:#121212;padding-left:10px;padding-right:10px><a href=/assets/resized/projects/ringboard/system-architecture-min.svg><img alt="Architecture block diagram" class=article-image height=351 loading=lazy src=/assets/resized/projects/ringboard/system-architecture-min.svg width=581></a></div><p>Note that I use the terms arena and bucket to mean the same thing (probably incorrectly).<h3 id=the-ring>The ring <a href=#the-ring class=header-link>#</a></h3><p>A Ringboard metadata store consists of 4-byte entries arranged in a fixed length ring buffer (resizing is discussed <a href=#ring-resizing>later</a>). If the user doesn’t have the maximum number of entries yet, adding a new entry appends to the metadata file. Once the maximum has been reached, we cycle around and begin overwriting previous entries. Deletions and moves are handled by uninitializing the old entry (skipping over such tombstone entries while reading), and (un)favoriting is handled by moving the entry between metadata rings.<p>Every ring includes a header with a 3 byte file signature (chosen by <a href=//xkcd.com/221/ >a fair dice roll</a> of course), the ring’s version (for future compatibility), and finally the write head (i.e. where the next entry should be written). The ring never shrinks and therefore does not need a tail pointer as the tail is implicitly encoded as the write head (while the head pointer is technically the write head minus one).<h4 id=ring-entries>Ring entries <a href=#ring-entries class=header-link>#</a></h4><p>Ring entries are a fixed size because this gives us a critical ability: the UI can perform simple pointer arithmetic with the write head to retrieve the N most recent entries. For example, displaying the last 100 entries requires reading just 400 bytes from disk—that’s a single disk block (or two if you’re unlucky and straddle two blocks). Compared to <a href=#background>GCH</a> and all other clipboard implementations I’ve looked at, this is by far the most efficient implementation for showing the N most recent entries. Most other clipboards must read in the entire database on startup, limiting scalability.<p>An important tradeoff to consider with fixed size entries is precisely the fact that they have a fixed size. Too much space for information and suddenly storing metadata becomes expensive, too little and it is no longer useful. I hope you’ll agree that 4 bytes is fairly space efficient:<ul><li>For small entries, the lower 12 bits store the size (in bytes) of the entry while the upper 20 bits store the location of the entry in its size bucket (see the next section for the data store implementation).<li>For large entries, the lower 12 bits are all zeros while the upper 20 bits simply need to be non-zero, but are otherwise unused currently.<li>Unallocated entries contain all zeros.</ul><p>In diagram form:<div class="highlighter-rouge language-plaintext"><div class=highlight><pre class=highlight><code>             [     20 bits     |    12 bits   ]
   Bucketed: [ Index in bucket | Entry length ]
Direct file: [     Non zero    |   All zero   ]
Unallocated: [            All zero            ]
</code></pre></div></div><p>Note that this encoding imposes a hard limit on the maximum number of representable entries: 2<sup>20</sup>’s worth. While a million entries should be more than enough, the all ones pattern in the upper 20 bits is reserved as an escape hatch to mean “this is an 8 byte entry,” thereby theoretically allowing more than ~1M entries even though such a feature hasn’t been implemented.<h3 id=the-data-store>The data store <a href=#the-data-store class=header-link>#</a></h3><p>At the end of the day, the data store is a glorified memory allocator and thus similar tradeoffs apply.<p>Storing entries contiguously is best for space efficiency, but leaves holes when entries are deleted. Holes could be avoided with generations, but now you must wait a very long time to truly delete an entry or face expensive compaction wherein all following entries must be moved.<p>Storing one entry per file is convenient but extremely inefficient for small entries due to the overhead of an inode.<p>Thus, I settled on arena style allocation where entries are bucketed into size classes and allocated from their respective arenas. In expectation, assuming a uniform entry length distribution (this is wrong, but close enough), about 25% of each bucket will be wasted space. The benefit is that holes from deleted entries can be filled in O(1) time. Was this the right choice? Probably? I still wonder if generations would have been better.<p>Specifically, there are 11 size classes in powers of two from 4 to 4096. Entries larger than that are stored in a file named by the composite ID of the entry (its ring ID and position in the ring). Any entry with a non-plaintext mime type is also stored in a file regardless of its size due to there being no metadata storage for bucket allocations. File mime types are stored in extended file attributes (which should be <a href=//kernel.org/doc/html/latest/filesystems/ext4/dynamic.html#extended-attributes>stored in the inode itself when small</a>).<p>Entries 4096 bytes or larger are allocated as one file per entry to avoid paying the 25% wasted space tax—they pay the O(1) inode plus directory entry cost instead.<p>Ring entries point to either a bucket allocation (implicitly choosing a size class via the entry size) or a direct file allocation. Moving an entry either does nothing in the case of bucket allocations or renames the direct file for direct allocations. Deleting an entry simply marks a slot in the arena as being free or deletes the direct allocation file.<h3 id=directory-structure>Directory structure <a href=#directory-structure class=header-link>#</a></h3><p><div class="highlighter-rouge language-plaintext"><div class=highlight><pre class=highlight><code>~/.local/share/clipboard-history/
├── buckets
│   ├── (0, 4]
│   ├── (4, 8]
│   ├── ...
│   ├── (1024, 2048]
│   └── (2048, 4096)
├── direct
│   ├── ...
│   └── 0004294985353
├── main.ring
├── favorites.ring
├── free-lists
└── server.lock
</code></pre></div></div><h2 id=the-server>The server <a href=#the-server class=header-link>#</a></h2><p>The server’s only job is to handle writes to the database. In fact, the server is the <em>only</em> process ever allowed to modify the database. However, it does not decide what to write down and therefore sits around waiting for commands from clients. A client could be a Wayland or X11 clipboard listener for example which will inform us when the user has copied something. Clients can also be GUIs that wish to modify the database or get notified of changes.<p>The server is implemented as a single-threaded event loop using <a href=//man7.org/linux/man-pages/man7/io_uring.7.html>io_uring</a>.<h3 id=protocol>Protocol <a href=#protocol class=header-link>#</a></h3><p>Importantly for performance, the server never sends data to clients. Instead, clients use a library for interfacing with the database in a read-only manner, thereby avoiding any bottlenecks in the server. Currently, clients don’t react to changes in the database, but <a href=//github.com/SUPERCILEX/clipboard-history/issues/12>there are plans</a> to keep clients up-to-date by having the server broadcast change details as they occur. For rare commands that change a large portion of the database (like garbage collection), clients would be told to reload the entire database. In practice, the primary flow would consist of a user copying something, the server getting notified via a client, and finally broadcasting the event to subscribed clients. Notice that if a client does not subscribe to updates or make modifications, it need not even connect to the server.<p>The command protocol consists simply of the in-memory representation of the command structs. To maintain forward compatibility, the client and server exchange protocol versions with each other and reject the connection if they do not match. This avoids issues when a client is running a newer binary than the server or vice versa. Perhaps in the future there may be a case for supporting backward compatibility, but for the moment the client and server must be built with strictly the same protocol.<h3 id=recovering-from-unexpected-shutdowns>Recovering from unexpected shutdowns <a href=#recovering-from-unexpected-shutdowns class=header-link>#</a></h3><p>To avoid wasting disk writes, the server keeps the list of free arena slots in-memory and (de)serializes them only on startup/shutdown. The free slots only being up-to-date in memory means that if you lose power while Ringboard is running, we’ll have no idea which slots are free.<p>A lock file is therefore used to detect unclean shutdowns: it is created when the server is started and explicitly deleted when the server is shut down through the happy path. Thus, any unexpected halt can be detected by the presence of the lock file. As a bonus, the lock file is also used to prevent multiple server instances from running concurrently.<p>If an unclean shutdown is detected on startup, the server will stream through every ring, building an allocation bitset to compute free bucket slot indices.<p>Note that there is no recovery from corruption due to failure while writing entries, but any potential corruption is localized. This is discussed <a href=#local-corruption>later</a>.<h3 id=rings-rings-everywhere>Rings, rings everywhere <a href=#rings-rings-everywhere class=header-link>#</a></h3><p>Io_uring—barring a few hiccups early on—has been a pleasure to work with. It made writing an efficient single-threaded server a breeze. To illustrate, consider signal handling: using <a href=//man7.org/linux/man-pages/man2/signalfd.2.html><code class="highlighter-rouge language-plaintext">signalfd</code></a>, we can post a read request to io_uring and handle graceful shutdown alongside the rest of the event loop. No need for blocking code, threads, or pipes to handle signals! The server’s simplicity is driven by the ability to write a clean event loop.<p>io_uring’s bounded nature enables the server’s low memory usage. Queues and buffers have a fixed size, meaning io_uring code can rely on a known capacity for external inputs. If clients overload the server, io_uring simply fails the request. This leads to natural backpressure, where (for example) if clients don’t reap replies fast enough, their send budget will be reduced.<h3 id=a-note-on-mmap-semantics>A note on <code class="highlighter-rouge language-plaintext">mmap</code> semantics <a href=#a-note-on-mmap-semantics class=header-link>#</a></h3><p>Memory mapped file coherence is simply delightful on Linux. Barring <a href=//yarchive.net/comp/linux/mmap_portability.html>wonky CPU architectures</a>, file modifications through syscalls like <code class="highlighter-rouge language-plaintext">write</code> will be reflected in the file mapped memory of any process. This is important because it allows us to mmap more memory than exists in the file! In fact, the ring mmaps enough space to hold the maximum number entries, even though the ring on disk may be completely empty.<p>The coherence between virtual memory and files enables us to avoid remapping the ring whenever it grows—we use standard <code class="highlighter-rouge language-plaintext">write</code> syscalls to write past the end of the ring and those changes are then reflected in the mapped memory. More precisely , if user space touches a page that does not have any backing bytes in the file, the program will segfault. However, if a non-zero number of bytes map to the page, then the entirety of the page becomes valid and the slices which contain no backing data are filled with zeros.<p>But why not write to the mapped memory directly? Setting aside the performance loss of extra page faults, Linux offers no guarantees on when newly written data is made visible to the file system. Importantly, this means there are no ordering guarantees between writes which is unacceptable for database reliability.<h2 id=clients>Clients <a href=#clients class=header-link>#</a></h2><p>Ringboard was originally intended to be a single application, but I quickly realized that it would be useful to support many different readers and writers at once. To make reading the database fast, clients need only interact with the server when they wish to modify data. Clients connect to the server via a socket if necessary or use a client SDK to read data from the database. This approach allows some clients to avoid ever connecting to the server as they only need to read data. Supporting multiple clients also means it is easy to allow saving clipboard entries from X11 or Wayland or a CLI etc. Similarly, any number of interfaces to the database can be built for different use cases from GUIs to JSON exports.<h3 id=receiving-copied-items-via-wayland-or-x11>Receiving copied items via Wayland or X11 <a href=#receiving-copied-items-via-wayland-or-x11 class=header-link>#</a></h3><p>Since Ringboard follows a client server architecture, the server knows nothing about the clipboard—it is simply a data store. This keeps the server focused, simple, and flexible. Clipboard monitoring is instead performed in a small binary whose only task is to listen for clipboard changes and send new entries to the server.<h4 id=an-aside-on-the-nature-of-clipboards-which-mime-type-to-use>An aside on the nature of clipboards: which mime type to use? <a href=#an-aside-on-the-nature-of-clipboards-which-mime-type-to-use class=header-link>#</a></h4><p>When you copy something, what format is the data in? You might think there is a canonical format for copied data, but far from it. Consider something as simple as copying this very sentence. What did you just copy? Plain text or HTML? The answer is both, depending on the context. If you paste into a word processor, it will try to match the format of whatever you’ve copied and will therefore ask for HTML. But if you <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>V</kbd>, you’re asking the word processor to paste in plain text so that’s what it will ask for. Fun fact: this is why the code copied from your favorite editor comes with that sweet sweet theme styling you worked so hard on. Try it! Copy code from your editor, then check the available data formats with <code class="highlighter-rouge language-plaintext">xclip -o -target TARGETS -selection clipboard</code>. You should see <code class="highlighter-rouge language-plaintext">text/html</code> in there. Now ask for that HTML with <code class="highlighter-rouge language-plaintext">xclip -o -target text/html -selection clipboard</code> and open it in a browser. Lookin’ good. 😎<p>The problem for a clipboard manager is that applications holding clipboard data are free to perform on-the-fly conversions. For example, Firefox offers a PNG, JPEG, AVIF, HTML, and other formats after copying an image. Supposing the clipboard <em>could</em> correctly save all the formats available, it would end up with many undesirable duplicate copies of the same entry. Unfortunately, retrieving all formats cannot even be done correctly as the owner of the clipboard data is free to do anything they like, such as returning different data each time you ask for it or performing lossy conversions (for example, copying an SVG in Chrome or Firefox doesn’t let you ask for the SVG and instead only offers a PNG conversion). Asking for copied items in every available format to try and capture the underlying data therefore isn’t practical or possible.<p>In fact, the system clipboard faces these same issues. When an application which owns the clipboard is closed, there is suddenly no way to ask it for the clipboard data. Thus, the compositor must store some version of the clipboard contents in memory so what you’ve copied doesn’t disappear after you close the application it was copied from. This process is lossy. It’s why pasting something from a closed application can behave differently than when it is open.<blockquote><p>Here are some further examples I used to convince myself I was on the right path:<ul><li>When copying something from a web page, it is quite rare to want the HTML version of the text.<li>The same logic applies to copied code: the vast majority of the time, you’re working and not trying to paste a pretty version in a slide deck. No point in remembering the pretty version forever.<li>When copying files in a file manager, you sometimes want the path and sometimes want to copy the file. For cases like this, the file object can be stored as the canonical representation and offered as a path by a conversion in our code.<li>The same applies to images: we can store a JXL for example and offer to convert it to a PNG.</ul><p>Finally, it’s worth remembering that Ringboard is a byte oriented database. If it turns out we need to store multiple mime types for some specific use case, we could store an entry with a special mime type (say <code class="highlighter-rouge language-plaintext">x-special/ringboard-multi</code>) containing a serialized object that describes each representation of the entry. The various clients will need code to handle this special mime type, not unlike how they have special code to handle <code class="highlighter-rouge language-plaintext">image/*</code> mime types.</blockquote><p>So what can we do? We guess, unfortunately. That means trying to pick the “best” format available to save (which as a reminder isn’t possible because the right format is dependent on the paste context). We use heuristics: for example, if an image is available we’ll pick the first mime type starting with “image/”. For anything not in our heuristics, we default to picking plain text. As a consequence, we need your help to improve these heuristics so they can handle your wonky mime type of choice. :)<h3 id=pasting-items>Pasting items <a href=#pasting-items class=header-link>#</a></h3><p>As mentioned above, the clipboard operates on a pull model: when someone wishes to paste, the current program asks whichever program owns the clipboard for its contents. This means that the clipboard owner must live at least long enough for the compositor to make a copy of the clipboard contents, and must live indefinitely if the program wishes to provide a full pasting experience with multiple mime types.<p>Thus, another server was needed to own the clipboard for a Ringboard entry, thereby reconciling the contradictory short-lived nature of a client and long-lived nature of a pasting program. Since the clipboard watcher already talks to the clipboard and is a long-lived daemon, the paste server was added alongside it.<p>The paste server is implemented with a simple <a href=//man7.org/linux/man-pages/man7/epoll.7.html>epoll</a> multiplexing mechanism over a connection-less Unix socket.<h3 id=gui-startup-latency-and-long-lived-client-windows>GUI startup latency and long-lived client windows <a href=#gui-startup-latency-and-long-lived-client-windows class=header-link>#</a></h3><p>Initializing a GUI can be quite slow (especially in X11): on the order of a few hundred milliseconds. Since this brief pause in someone’s train of thought while trying to paste a previous clipboard entry would be extremely annoying, GUI clients make their windows invisible when closed rather than completely quitting. To reopen the window, a special file can be deleted which wakes the GUI via <a href=//man7.org/linux/man-pages/man7/inotify.7.html>inotify</a>. If, instead, a new instance of the GUI is opened, this special file is used to first check for a previously running instance of the GUI and kill it if it exists.<h2 id=advanced-features>Advanced features <a href=#advanced-features class=header-link>#</a></h2><h3 id=search>Search <a href=#search class=header-link>#</a></h3><p>Search is always tricky in settings like these. A full-blown index feels wasteful to maintain and store for such little data (even 100K entries at an average of 100 bytes is only 10MB), but scanning through the whole database is also ugly. Still, I went with the ugly approach for its minimal overhead in the server.<p>Thanks to our arenas, it is easy to parallelize search in an optimal way for the hardware. Each arena is linearly searched on its own thread which means we are performing a (mostly) linear scan of the data. The rings are not involved at all. As a consequence, we will search through deleted entries and don’t know how long each entry is. If a result is found in a deleted entry, we simply ignore it later. As for knowing the length of each entry, the server places a NUL byte at the end of each entry for search to stop at. Note that search therefore does not work properly on entries which contain NUL bytes as data.<p>On another thread, the directory of direct allocation files is scanned and each file is searched when its mime type suggests the file contains text. Currently, no additional parallelism is used, but large files could be searched on their own threads to avoid bottlenecking on direct allocation search.<p>Finally, applications will likely want to know the entry which owns the search result. To do so, they build a reverse mapping of bucket slots to entry IDs by scanning through every ring. Thankfully, this mapping can be computed in parallel to the search and reused across searches, so is not too expensive. Furthermore, if applications do not need the entry ID for something (for example they only wish to copy the data somewhere), then there is no need to build this reverse mapping.<h3 id=garbage-collection>Garbage collection <a href=#garbage-collection class=header-link>#</a></h3><p>Since deleting bucket entries can leave holes anywhere in the relevant arena, we end up with garbage bucket slots which hurt search performance and waste space. There is also garbage in the form of tombstone entries in the ring, but their numbers are bounded and they are guaranteed to be reused, so we do not worry about them.<p>To determine when to remove dead bucket slots, we have several policies to choose from:<ul><li>Do nothing. Under a continuous random process of adding and removing entries, all garbage will eventually be reused. Unfortunately, this process also leads to eventually infinite garbage.<li>Always remove the garbage immediately. This wastes a lot of work and disk I/O when new entries could have reused an arena slot that was freed not too long ago.<li>Remove garbage on a schedule, for example when the server starts up and every N days thereafter. I’m not a fan of startup latency. Additionally, this policy allows garbage to grow unbounded between collections.<li>Remove garbage immediately when it’s created, but only if the total amount of garbage exceeds a threshold.</ul><p>I chose the last option because it guarantees an upper bound on the maximum amount of garbage and keeps a small amount of useful garbage around. Specifically, when a GC occurs we only remove enough garbage to put ourselves under the maximum amount threshold (plus a little more to avoid excessive collections), inhibiting a big sawtooth pattern that would occur if all garbage was removed when the threshold is exceeded. This makes the removal process more complicated because we must now choose <em>which</em> garbage to remove. Since we expect bucket allocation sizes to follow some distribution (copying lots of words/phrases is more common than whole paragraphs for example), freed bucket slots will therefore also match that distribution (though a distribution change will take time to propagate). Thus, we can expect the number of free slots per size class to be approximately uniform as the alloc and free distributions pair off. This means we should uniformly remove garbage from each size class, one layer at a time.<p>To minimize disk I/O when removing garbage, we fill unallocated/garbage bucket slots with allocated entries from the end of the arena. Once we only have (newly) unallocated slots at the end of an arena, we truncate the arena file to drop those dead slots. To further encourage usage of free slots near the beginning of the arena, we sort the free lists so that earlier slots are filled first.<p>A client pass is also available that first deduplicates the entire database before running garbage collection for extra space savings. This works by computing a hash of every single entry and when two hashes collide, checking to see if the contents of the two entries match, deleting the oldest entry if so.<h3 id=ring-resizing>Ring resizing <a href=#ring-resizing class=header-link>#</a></h3><p>Currently, the maximum number of entries is hardcoded, but <a href=//github.com/SUPERCILEX/clipboard-history/issues/9>there are plans</a> to support changing this default after the database has been created.<h2 id=flaws>Flaws <a href=#flaws class=header-link>#</a></h2><h3 id=blocking-reads>Blocking reads <a href=#blocking-reads class=header-link>#</a></h3><p>Io_uring <a href=//github.com/axboe/liburing/issues/831>doesn’t support</a> the <a href=//man7.org/linux/man-pages/man2/copy_file_range.2.html><code class="highlighter-rouge language-plaintext">copy_file_range</code></a> syscall which means we can’t copy client data asynchronously using io_uring. Even if <code class="highlighter-rouge language-plaintext">copy_file_range</code> was supported, as a practical matter, manually writing a coroutine to make all syscalls on the database write path async would be intractable. Thus, database modifications block the entire server, meaning one client can DoS the server. This is easy to reproduce by writing some code that asks the server to write an entry whose contents is <code class="highlighter-rouge language-plaintext">stdin</code>—the server will be frozen until <code class="highlighter-rouge language-plaintext">stdin</code> is closed.<p>I don’t believe this is a problem since we assume that clients are cooperative (see <a href=#error-handling-and-malicious-actors>below</a>) and therefore assume they will provide the server with a non-blocking file. However, if some unforeseen circumstances change the equation, then there is a relatively straightforward solution: move the allocator to a background thread and communicate with it using SPSC channels. The background thread would write into a pipe whenever it has sent a message so that io_uring can wake up and process allocator responses. However, keeping track of pending requests and applying backpressure would be complicated, hence why this approach wasn’t chosen.<h3 id=database-reliability>Database reliability <a href=#database-reliability class=header-link>#</a></h3><p>Both of these issues should be extremely rare (if not impossible) to hit under normal circumstances. Nevertheless, their possibility sucks and is sad to think about.<h4 id=local-corruption>Local corruption <a href=#local-corruption class=header-link>#</a></h4><p>On disk, the one rule offering some saving grace is that the database as a whole may never be corrupted. This is an improvement over Gnome Clipboard History which could be destroyed by a single bad bit, but it still means that Ringboard is susceptible to local corruption. Metadata being a fixed size means a corrupted entry does not affect the others, but by separating metadata from data we introduce a race between changing the data and the metadata. For example, crashing before the data has been flushed to disk but after the metadata has flushed will lead to corruption when adding an entry.<p>This could be easily fixed with an <code class="highlighter-rouge language-plaintext">fsync</code>, but there are more complicated cases that can’t be solved without journaling: if a non-bucket entry is deleted, its file and ring entry must be deallocated, but there is no order in which these operations can be performed without corruption of some form given a crash between the two operations. If the metadata is removed first and we crash, we’ll forget that we need to delete the data file; if the data is deleted first, then the metadata will end up pointing to the void.<p>Thus, I decided that local ring corruption was acceptable given the enhanced efficiency of not using a journal.<h4 id=raciness>Raciness <a href=#raciness class=header-link>#</a></h4><p>The project’s biggest shortcoming is caused by clients being able to independently read the database while it is being modified, leading to inherent race conditions.<p>In memory, clients do not have any control over writes the server executes, meaning a client could be using a buffer the server deallocates. For intended use cases (like garbage collection), this can be solved by notifying clients to reload the database, but there could be awkward situations where, for example, a client is looking at an old search result that gets overwritten by a new entry. While clients should watch for such changes, the possibility for nonsensical memory reads remains.<p>This case could be solved by having clients ask the server to lock ring ranges or by having the server ask clients for permission to modify ring entries (two-phase commit), but I decided that the complexity and overhead was unnecessary for a clipboard manager. As a reminder, clients can never modify data and therefore memory errors are transient which makes them slightly more acceptable.<h3 id=error-handling-and-malicious-actors>Error handling and malicious actors <a href=#error-handling-and-malicious-actors class=header-link>#</a></h3><p>In general, the Ringboard server takes the view that clients are good citizens and try to share resources amongst each other. This unfortunately means that the server doesn’t try particularly hard (if at all in many cases) to recover from runtime errors. If something goes wrong, the server will simply shut down with an error message (to be clear, the server should never <em>crash</em>, but it is allowed to die).<p>I went with minimal error recovery for two reasons. First, clients <em>want</em> to be good citizens. A user is installing clients on their own machine—why install a client that will shoot them in the foot? Second, error recovery is <em>hard</em>. You are writing code that will almost never be executed and probably requires a convoluted set of conditions to be met before firing. For a clipboard manager, I would rather have maintainable code that almost never fails but may need to reboot if things are broken than code which must gracefully recover from every I/O error.<h3 id=complexity>Complexity <a href=#complexity class=header-link>#</a></h3><p>At the end of the day, Ringboard is a very complicated project with a lot of moving pieces and a simple sounding goal: remember stuff you’ve copied. Thus, the question must be asked: is this complexity worth it? I believe the answer is yes. Simple projects get the job done, but sooner or later, they end up wanting more functionality and better performance. Without the discipline to accept their limitations, these projects are inevitably rewritten as they grow organically. I prefer the philosophy of writing things once and getting them right the first time. If “right” still comes with compromises as is almost always the case, then those compromises must be accepted and core functionality changes rejected in order to maintain the original vision. Core changes are what v2 projects are for—in other words, Ringboard is Gnome Clipboard History’s v2.<h2 id=random-whining>Random whining <a href=#random-whining class=header-link>#</a></h2><h3 id=writing-fast-and-maintainable-code-is-still-stinkin-impossible>Writing fast <em>and</em> maintainable code is still stinkin’ impossible <a href=#writing-fast-and-maintainable-code-is-still-stinkin-impossible class=header-link>#</a></h3><p>To get a sense for what I mean, consider an API for a case-insensitive plaintext search API. The maintainable version might look something like this:<div class="highlighter-rouge language-rust"><div class=highlight><pre class=highlight><code><span class=k>fn</span> <span class=nf>search</span><span class=p>(</span><span class=n>query</span><span class=p>:</span> <span class=o>&</span><span class=nb>str</span><span class=p>)</span> <span class=k>-></span> <span class=n>Results</span> <span class=p>{</span>
  <span class=nf>do_stuff</span><span class=p>(</span><span class=o>&</span><span class=n>query</span><span class=nf>.to_ascii_lowercase</span><span class=p>()</span><span class=nf>.trim</span><span class=p>())</span>
<span class=p>}</span>
</code></pre></div></div><p>The problem is that <code class="highlighter-rouge language-plaintext">to_ascii_lowercase</code> allocates a <code class="highlighter-rouge language-plaintext">String</code> on the heap and all you need at the end of the day is an <code class="highlighter-rouge language-plaintext">&str</code>. You look at your call sites and see that they all already have a <code class="highlighter-rouge language-plaintext">String</code>, so you decide to reuse it:<div class="highlighter-rouge language-rust"><div class=highlight><pre class=highlight><code><span class=k>fn</span> <span class=nf>search</span><span class=p>(</span><span class=n>query</span><span class=p>:</span> <span class=o>&</span><span class=k>mut</span> <span class=nb>String</span><span class=p>)</span> <span class=k>-></span> <span class=n>Results</span> <span class=p>{</span>
  <span class=n>query</span><span class=nf>.make_lowercase_ascii</span><span class=p>();</span>
  <span class=nf>do_stuff</span><span class=p>(</span><span class=n>query</span><span class=nf>.trim</span><span class=p>())</span>
<span class=p>}</span>
</code></pre></div></div><p>But now you want to trim the <code class="highlighter-rouge language-plaintext">query</code> in some places but not others… well too bad because <code class="highlighter-rouge language-plaintext">.trim()</code> returns an <code class="highlighter-rouge language-plaintext">&str</code> (as an in-place trim would have to move all the bytes over), so you’re back to needing an extra allocation, at the call site this time: <code class="highlighter-rouge language-plaintext">search(query.trim().to_string())</code>. The only way to remove the extra allocation is to bleed your requirements across function boundaries:<div class="highlighter-rouge language-rust"><div class=highlight><pre class=highlight><code><span class=n>query</span><span class=nf>.make_lowercase_ascii</span><span class=p>();</span>
<span class=nf>search</span><span class=p>(</span><span class=n>query</span><span class=nf>.trim</span><span class=p>());</span>

<span class=c1>// …</span>

<span class=k>fn</span> <span class=nf>search</span><span class=p>(</span><span class=n>query</span><span class=p>:</span> <span class=o>&</span><span class=nb>str</span><span class=p>)</span> <span class=k>-></span> <span class=n>Results</span> <span class=p>{</span>
  <span class=nd>debug_assert!</span><span class=p>(</span><span class=n>query</span><span class=nf>.is_ascii_lowercase</span><span class=p>());</span>
  <span class=nf>do_stuff</span><span class=p>(</span><span class=n>query</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div></div><p>This pattern where a caller already has a costly object ready that can’t easily be used in the maintainable API shows up all the time in low-level code. I feel like this might be fundamentally unsolvable as the API needs to know call site implementation details to be fast. Perhaps <a href=//github.com/rust-lang/rfcs/blob/master/text/1210-impl-specialization.md>specialization</a> could help, but I haven’t thought deeply about it.<h3 id=error-handling-still-sucks-especially-in-guis>Error handling still sucks, especially in GUIs <a href=#error-handling-still-sucks-especially-in-guis class=header-link>#</a></h3><p>I’m tired of writing <code class="highlighter-rouge language-plaintext">map_err</code> every two seconds to provide context on why an error occurred. And no, being lazy and just returning the <code class="highlighter-rouge language-plaintext">io::Error</code> as is so you get a <code class="highlighter-rouge language-plaintext">File not found</code> error with no file path to tell you where the error came from is not acceptable. In GUIs, the story gets even more annoying: not only does any external action need to handle errors, but you then need a dedicated place in the GUI to display those errors so the app doesn’t just silently do nothing. Testing it is a nightmare because the errors never happen in practice so you have to temporarily comment out the working code to return fake errors. Sometimes I wonder if <code class="highlighter-rouge language-plaintext">.expect</code>ing everything might be the way to go.<h3 id=writing-guis-that-spark-joy-is-a-pain-especially-in-rust>Writing GUIs that spark joy is a pain, especially in Rust <a href=#writing-guis-that-spark-joy-is-a-pain-especially-in-rust class=header-link>#</a></h3><p>Until our Lord and Savior Raph Levien blesses us all with <a href=//linebender.org>glorious Rust GUI</a>, simpletons like me live in existential agony desperately trying to smooth out a stuttering, buggy mess of a GUI that looks like it came from an engineer’s nightmarish disdain for any form over function. I hate GUIs. So much.<p><code class="highlighter-rouge language-plaintext">egui</code> in particular just isn’t ready for real-world UIs: achieving desired behavior is buggy and finicky. Then again, I would say the same thing about Android development and HTML/CSS so perhaps all UI is cursed.<h2 id=conclusion>Conclusion <a href=#conclusion class=header-link>#</a></h2><p>Hopefully this overview of Ringboard provides adequate insights into its inner workings and the reasoning behind its design choices. In a perfect world, Ringboard’s design is flexible enough to support self-sustaining communities around each client implementation.<p>Happy copying!</div></div></div></div></div></div><footer class=text-defaults><small>Copyright © 2018-2025 Alex Saveau</small> <small><a href=//github.com/SUPERCILEX/personal-website>Source</a> | <a href=//twitter.com/SUPERCILEX>Twitter</a> | <a href=#top>Back to top</a></small></footer>