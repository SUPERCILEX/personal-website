<!doctype html><html class=min-height-full lang=en><meta charset=utf-8><meta content="width=device-width,initial-scale=1,shrink-to-fit=no" name=viewport><meta content="light dark" name=color-scheme><link href=/favicon.ico rel=icon type=image/x-icon><link href=//fonts.gstatic.com/s/atkinsonhyperlegible/v10/9Bt23C1KxNDXMspQ1lPyU89-1h6ONRlW45G04pIo.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/feed.xml rel=alternate type=application/atom+xml title="Alex Saveau"><title>Survival guide: how to migrate from the Firebase Realtime Database to Cloud Firestore | Alex Saveau</title><meta content="Jekyll v4.3.2" name=generator><meta content="Survival guide: how to migrate from the Firebase Realtime Database to Cloud Firestore" property=og:title><meta content="Alex Saveau" name=author><meta content=en_US property=og:locale><meta content="Ever since Google‚Äôs new mobile SDKs were announced two years ago at I/O, the Firebase empire has been ever-expanding. It now supports more and more features, such as Cloud Functions, phone authentication, and performance monitoring. However, one SDK that hasn‚Äôt changed much is the Firebase Realtime Database (RTDB)." name=description><meta content="Ever since Google‚Äôs new mobile SDKs were announced two years ago at I/O, the Firebase empire has been ever-expanding. It now supports more and more features, such as Cloud Functions, phone authentication, and performance monitoring. However, one SDK that hasn‚Äôt changed much is the Firebase Realtime Database (RTDB)." property=og:description><link href=https://alexsaveau.dev/blog/firebase/android/survival-guide-how-to-migrate-from-the-firebase-realtime-database-to-cloud-firestore rel=canonical><meta content=https://alexsaveau.dev/blog/firebase/android/survival-guide-how-to-migrate-from-the-firebase-realtime-database-to-cloud-firestore property=og:url><meta content="Alex Saveau" property=og:site_name><meta content=https://alexsaveau.dev/assets/resized/firebase/firestore-banner-800-min.jpg property=og:image><meta content=article property=og:type><meta content=2017-12-12T00:00:00+00:00 property=article:published_time><meta content=summary_large_image name=twitter:card><meta content=https://alexsaveau.dev/assets/resized/firebase/firestore-banner-800-min.jpg property=twitter:image><meta content="Survival guide: how to migrate from the Firebase Realtime Database to Cloud Firestore" property=twitter:title><meta content=@SUPERCILEX name=twitter:site><meta content=@SUPERCILEX name=twitter:creator><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Alex Saveau"},"dateModified":"2022-11-02T06:55:47+00:00","datePublished":"2017-12-12T00:00:00+00:00","description":"Ever since Google‚Äôs new mobile SDKs were announced two years ago at I/O, the Firebase empire has been ever-expanding. It now supports more and more features, such as Cloud Functions, phone authentication, and performance monitoring. However, one SDK that hasn‚Äôt changed much is the Firebase Realtime Database (RTDB).","headline":"Survival guide: how to migrate from the Firebase Realtime Database to Cloud Firestore","image":"https://alexsaveau.dev/assets/resized/firebase/firestore-banner-800-min.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"https://alexsaveau.dev/blog/firebase/android/survival-guide-how-to-migrate-from-the-firebase-realtime-database-to-cloud-firestore"},"url":"https://alexsaveau.dev/blog/firebase/android/survival-guide-how-to-migrate-from-the-firebase-realtime-database-to-cloud-firestore"}</script><script>window.addEventListener("DOMContentLoaded",()=>{for(let e of document.querySelectorAll(".loads")){var o=()=>{e.classList.remove("loads")};e.complete?o():(e.onload=o,e.onerror=o)}})</script><noscript><style>.loads{animation:none!important;background-color:unset!important}</style></noscript><link href=//fonts.gstatic.com/s/firacode/v17/uU9NCBsR6Z2vfE9aq3bh3dSD.woff2 rel=preload type=font/woff2 as=font crossorigin><style>@keyframes tooltip-appear{0%{opacity:0}to{opacity:1}}@keyframes pulse{0%,to{opacity:1}50%{opacity:.33}}:root{--progress-color:gray;--blockquote-color:#6a737d;--blockquote-boarder-color:#959da5;--code-background-color:rgba(0, 0, 0, 0.05);--hr-color:gray;--footer-color:white;--loading-pulse-color:#b0b0b0}@font-face{font-family:"Fira Code";font-style:normal;font-weight:475;font-display:swap;src:url(//fonts.gstatic.com/s/firacode/v17/uU9NCBsR6Z2vfE9aq3bh3dSD.woff2) format("woff2");unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}.article{overflow-wrap:break-word}.article .highlight{background-color:rgba(0,0,0,.04);border-radius:3px}.article .caption{font-size:1rem;margin:-1.5em 0 0}.article .gist-caption{font-size:1rem;margin:-.5em 0 0}.article .gist-caption code{font-size:.875rem}.article h2,.article h3{margin:1.5em 0-.5em}.article h2{font-size:1.875rem}.article h3{font-size:1.5rem}.article p{font-size:1.313rem;margin:.95em 0 1.2em}.article p.caption{text-align:center}.article img.article-image{width:100%;height:auto}.article strong{font-size:1.25rem}.article code{font-family:"Fira Code",monospace;font-size:1rem;background-color:var(--code-background-color);border-radius:3px;padding:2px 4px}.article blockquote{border-left:4px solid var(--blockquote-boarder-color);padding-left:16px;margin-bottom:16px;margin-left:0;margin-right:0}.article blockquote :not(a){color:var(--blockquote-color)}.article div pre{padding:20px}.article div pre code,a{background-color:transparent}.article div pre code{padding:0}.article ol,.article ul{font-size:1.313rem;padding-left:32px;margin-bottom:16px}.header-link{visibility:hidden}h2:hover .header-link,h3:hover .header-link{visibility:visible}@media (prefers-color-scheme:dark){:root{--progress-color:whitesmoke;--blockquote-color:#dadada;--blockquote-boarder-color:#dadada;--code-background-color:rgba(255,255,255,0.15)}.article .caption,.article .gist-caption{color:#dadada}.article p{color:#ededed}.article img:not([src*=".svg"]){filter:brightness(.8) contrast(1.1)}.highlight pre{background-color:#272822}}.octicon{display:inline-block;fill:currentColor;vertical-align:text-bottom}html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji";line-height:1.5;color:#24292e;background-color:#fff;font-family:Atkinson Hyperlegible,sans-serif;font-size:1em}footer{display:block;display:flex;padding:5px;align-items:center;background-color:var(--footer-color)}a{color:#0366d6;text-decoration:none}a:active,a:hover{outline-width:0}strong{font-weight:600}h1{margin:.67em 0}small{font-size:90%}img{border-style:none}svg:not(:root){overflow:hidden}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}*{box-sizing:border-box}a:hover{text-decoration:underline}h1,h2,h3,ol,p,pre,ul{margin-top:0;margin-bottom:0}h1,h2,h3{font-size:2rem;font-weight:600}h2,h3{font-size:1.5rem}h3{font-size:1.25rem}p{margin-bottom:10px}blockquote{margin:0}ol,ul{padding-left:0}code,pre{font-family:SFMono-Regular,Consolas,"Liberation Mono",Menlo,monospace;font-size:.75rem}:-ms-input-placeholder{color:#6a737d;opacity:1}::-ms-input-placeholder{color:#6a737d;opacity:1}:checked+.radio-label{position:relative;z-index:1;border-color:#0366d6}@media (min-width:768px){.col-md-5{width:41.66667%}.col-md-7{width:58.33333%}}@media (min-width:1012px){.col-lg-4{width:33.33333%}.col-lg-8{width:66.66667%}}@media (min-width:1280px){.col-xl-3{width:25%}.col-xl-9{width:75%}}.tooltipped{position:relative}.tooltipped::after,.tooltipped::before{position:absolute;display:none;pointer-events:none;opacity:0}.tooltipped::after{z-index:1000000;padding:.5em .75em;font:11px/1.5 -apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji";-webkit-font-smoothing:subpixel-antialiased;color:#fff;text-align:center;text-decoration:none;text-shadow:none;text-transform:none;letter-spacing:normal;word-wrap:break-word;white-space:pre;content:attr(aria-label);background:#1b1f23;border-radius:6px}.tooltipped::before{z-index:1000001;width:0;height:0;color:#1b1f23;content:"";border:6px solid transparent}.tooltipped:active::after,.tooltipped:active::before,.tooltipped:focus::after,.tooltipped:focus::before,.tooltipped:hover::after,.tooltipped:hover::before{display:inline-block;text-decoration:none;animation-name:tooltip-appear;animation-duration:.1s;animation-fill-mode:forwards;animation-timing-function:ease-in;animation-delay:.4s}.tooltipped-se::after{top:100%;margin-top:6px}.tooltipped-se::before{top:auto;right:50%;bottom:-7px;margin-right:-6px;border-bottom-color:#1b1f23}.tooltipped-se::after{right:auto;left:50%;margin-left:-16px}.border-top{border-top:1px solid #e1e4e8!important}@media (min-width:768px){.border-md-right{border-right:1px solid #e1e4e8!important}.border-md-bottom{border-bottom:1px solid #e1e4e8!important}.border-md-top-0{border-top:0!important}}.circle{border-radius:50%!important}.border-gray-light{border-color:#eaecef!important}.bg-white{background-color:#fff!important}.bg-gray-light{background-color:#fafbfc!important}.text-gray{color:#586069!important}.flex-wrap{flex-wrap:wrap!important}.flex-items-start{align-items:flex-start!important}.flex-items-center{align-items:center!important}.flex-self-stretch{align-self:stretch!important}.v-align-middle{vertical-align:middle!important}.mr-2{margin-right:8px!important}.mx-auto{margin-right:auto!important;margin-left:auto!important}.px-4{padding-right:24px!important;padding-left:24px!important}.f4{font-size:1rem!important}@media (min-width:768px){.px-md-6{padding-right:40px!important;padding-left:40px!important}.f4{font-size:1rem!important}}.f5{font-size:.875rem!important}.f00-light{font-size:2.5rem!important;font-weight:300!important}@media (min-width:768px){.f00-light{font-size:3rem!important}}.f2-light{font-size:1.375rem!important;font-weight:300!important}.lh-condensed{line-height:1.25!important}.d-flex{display:flex!important}.d-none{display:none!important}@font-face{font-family:Inter;font-style:normal;font-weight:400;src:local("Inter"),local("Inter-Regular"),url(/fonts/Inter-Regular.woff) format("woff");font-display:swap}@font-face{font-family:Inter;font-style:normal;font-weight:500;src:local("Inter Medium"),local("Inter-Medium"),url(/fonts/Inter-Medium.woff) format("woff");font-display:swap}@font-face{font-family:Inter;font-style:normal;font-weight:600;src:local("Inter Bold"),local("Inter-Bold"),url(/fonts/Inter-Bold.woff) format("woff");font-display:swap}.mb-2{margin-bottom:8px!important}.mb-3{margin-bottom:16px!important}.mb-5{margin-bottom:32px!important}.mb-6{margin-bottom:40px!important}.py-6{padding-top:40px!important;padding-bottom:40px!important}.highlight{width:100%;overflow:auto;background:#fff}@font-face{font-family:"Atkinson Hyperlegible";font-style:normal;font-weight:400;font-display:swap;src:url(//fonts.gstatic.com/s/atkinsonhyperlegible/v10/9Bt23C1KxNDXMspQ1lPyU89-1h6ONRlW45G04pIo.woff2) format("woff2");unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}footer small{width:100%}footer small:last-child{text-align:end}.min-height-full{min-height:100vh}.icon-color{fill:#24292e!important}.loads{animation-duration:2s;animation:2s cubic-bezier(.4,0,.6,1) infinite pulse;animation-timing-function:cubic-bezier(.4,0,.6,1);animation-iteration-count:infinite;animation-name:pulse;background-color:var(--loading-pulse-color)}@media (min-width:768px){.f2-light{font-size:1.5rem!important}.d-md-flex{display:flex!important}#masthead{position:fixed;width:min-content}.masthead-name-mobile{display:none}}@media (max-width:768px){.masthead-mini{padding-top:10px!important;padding-bottom:10px!important}.masthead-mini-container{display:flex;align-items:center}.masthead-profile{width:80px;height:80px;margin-bottom:0!important}.masthead-intro{padding-left:24px}.masthead-name{display:none}.masthead-bio{margin-bottom:0!important}.masthead-metadata{display:none}}@media (min-width:1942px){.masthead{max-width:400px}.content-container{width:100%}}@media (prefers-color-scheme:dark){:root{--hr-color:whitesmoke;--footer-color:black;--loading-pulse-color:#383838}a{color:unset!important;text-decoration:underline}.bg-white{background-color:#4f565d!important}.bg-gray-light{background-color:#2f363d!important}.border-gray-light{border-color:transparent!important}.text-gray{color:#d0d8e1!important}.border-md-bottom{border:0!important}.masthead{background-color:#24292e!important}.scoped-text-defaults,.text-defaults,.text-defaults *{color:#fff!important}.icon-color{fill:#fff!important}}</style><body class=min-height-full id=top><div class="min-height-full bg-gray-light border-md-bottom d-md-flex"><div class="px-4 px-lg-7 py-6 bg-white border-gray-light border-md-right col-lg-4 col-md-5 col-xl-3 flex-self-stretch masthead masthead-mini px-md-6"><div class=masthead-mini-container id=masthead><a href=/ ><picture><source sizes=150px srcset="/assets/resized/me2-240-min.avif 240w, /assets/resized/me2-320-min.avif 320w, /assets/resized/me2-480-min.avif 480w, /assets/resized/me2-800-min.avif 800w, /assets/resized/me2-min.avif 1528w" type=image/avif><source sizes=150px srcset="/assets/resized/me2-240-min.jpg 240w, /assets/resized/me2-320-min.jpg 320w, /assets/resized/me2-480-min.jpg 480w, /assets/resized/me2-800-min.jpg 800w, /assets/resized/me2-min.jpg 1528w" type=image/jpeg><source sizes=150px srcset="/assets/resized/me2-240.jpg 240w, /assets/resized/me2-320.jpg 320w, /assets/resized/me2-480.jpg 480w, /assets/resized/me2-800.jpg 800w, /assets/me2.jpg 1528w"><img alt="Profile Picture" class="loads circle masthead-profile mb-3" height=150 loading=lazy src=/assets/resized/me2-240.jpg width=150></picture></a><div class=masthead-intro><h1 class="text-defaults lh-condensed mb-2 masthead-name">Alex Saveau</h1><h2 class="text-defaults lh-condensed mb-2 masthead-name-mobile">Alex Saveau</h2><p class="text-gray f4 masthead-bio mb-3" id=bio>Relentless efficiency</div><div class="f4 masthead-metadata"><div class="text-defaults d-flex flex-items-center mb-3"><svg height=20 viewBox="0 0 16 16" aria-label=GitHub class="icon-color mr-2 octicon v-align-middle octicon-mark-github" role=img version=1.1 width=20><path d="M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z"></path></svg> <a href=//github.com/SUPERCILEX>@SUPERCILEX</a></div><div class="text-defaults d-flex flex-items-center mb-3"><svg height=20 viewBox="0 0 16 16" aria-label=email class="icon-color mr-2 octicon v-align-middle octicon-mail" role=img version=1.1 width=20><path d="M1.75 2h12.5c.966 0 1.75.784 1.75 1.75v8.5A1.75 1.75 0 0 1 14.25 14H1.75A1.75 1.75 0 0 1 0 12.25v-8.5C0 2.784.784 2 1.75 2ZM1.5 12.251c0 .138.112.25.25.25h12.5a.25.25 0 0 0 .25-.25V5.809L8.38 9.397a.75.75 0 0 1-.76 0L1.5 5.809v6.442Zm13-8.181v-.32a.25.25 0 0 0-.25-.25H1.75a.25.25 0 0 0-.25.25v.32L8 7.88Z"></path></svg> <a href=mailto:saveau.alexandre@gmail.com>saveau.alexandre@gmail.com</a></div><div class="flex-items-start d-flex flex-wrap"><div class=mb-3><a href=//stackoverflow.com/u/4548500 class="tooltipped tooltipped-se" aria-label="Stack Overflow: 4548500"><svg height=24 viewBox="0 0 120 120" fill=#959da5 xmlns=http://www.w3.org/2000/svg><path d="M84.4 93.8V70.6h7.7v30.9H22.6V70.6h7.7v23.2z" class=st0 /><path d="M38.8 68.4l37.8 7.9 1.6-7.6-37.8-7.9-1.6 7.6zm5-18l35 16.3 3.2-7-35-16.4-3.2 7.1zm9.7-17.2l29.7 24.7 4.9-5.9-29.7-24.7-4.9 5.9zm19.2-18.3l-6.2 4.6 23 31 6.2-4.6-23-31zM38 86h38.6v-7.7H38V86z" class=st1 /></svg><span class=d-none>Stack Overflow</span></a></div></div></div></div></div><div class="px-4 px-lg-7 py-6 border-md-top-0 border-top col-lg-8 col-md-7 col-xl-9 content-container" id=article><div class=mx-auto style=max-width:900px><div class="f4 mb-6"><div class="f4 scoped-text-defaults"><p class=f5><a href=/blog class="text-defaults d-flex flex-items-center"><svg height=16 viewBox="0 0 16 16" aria-label=include.parent class="icon-color mr-2 octicon v-align-middle octicon-chevron-left" role=img version=1.1 width=16><path d="M9.78 12.78a.75.75 0 0 1-1.06 0L4.47 8.53a.75.75 0 0 1 0-1.06l4.25-4.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042L6.06 8l3.72 3.72a.75.75 0 0 1 0 1.06Z"></path></svg>Blog</a><h1 class="text-defaults lh-condensed f00-light" style=font-weight:600!important>Survival guide: how to migrate from the Firebase Realtime Database to Cloud Firestore</h1><h2 class="text-gray f2-light lh-condensed" style=font-weight:400!important></h2><p class="text-gray mb-5">Published Dec 12, 2017 ‚Ä¢ Last updated Nov 02, 2022 ‚Ä¢ 35 min read<div class=article><p><a href=/assets/firebase/firestore-banner.png><picture><source sizes="(min-width: 768px) 85vw, 100vw" srcset="/assets/resized/firebase/firestore-banner-240-min.avif 240w, /assets/resized/firebase/firestore-banner-320-min.avif 320w, /assets/resized/firebase/firestore-banner-480-min.avif 480w, /assets/resized/firebase/firestore-banner-800-min.avif 800w, /assets/resized/firebase/firestore-banner-1600-min.avif 1600w, /assets/resized/firebase/firestore-banner-3200-min.avif 3200w, /assets/resized/firebase/firestore-banner-min.avif 4000w" type=image/avif><source sizes="(min-width: 768px) 85vw, 100vw" srcset="/assets/resized/firebase/firestore-banner-240-min.jpg 240w, /assets/resized/firebase/firestore-banner-320-min.jpg 320w, /assets/resized/firebase/firestore-banner-480-min.jpg 480w, /assets/resized/firebase/firestore-banner-800-min.jpg 800w, /assets/resized/firebase/firestore-banner-1600-min.jpg 1600w, /assets/resized/firebase/firestore-banner-3200-min.jpg 3200w, /assets/resized/firebase/firestore-banner-min.jpg 4000w" type=image/jpeg><source sizes="(min-width: 768px) 85vw, 100vw" srcset="/assets/resized/firebase/firestore-banner-240.png 240w, /assets/resized/firebase/firestore-banner-320.png 320w, /assets/resized/firebase/firestore-banner-480.png 480w, /assets/resized/firebase/firestore-banner-800.png 800w, /assets/resized/firebase/firestore-banner-1600.png 1600w, /assets/resized/firebase/firestore-banner-3200.png 3200w, /assets/firebase/firestore-banner.png 4000w"><img alt="Firestore Banner" class="loads article-image" height=938 loading=lazy src=/assets/resized/firebase/firestore-banner-240.png width=4000></picture></a><div class=text-gray><p class=caption>The long-awaited database revamp is here!</div><br><p>Ever since Google‚Äôs new mobile SDKs were <a href=//firebase.googleblog.com/2016/05/firebase-expands-to-become-unified-app-platform.html>announced</a> two years ago at I/O, the Firebase empire has been ever-expanding. It now supports more and more features, such as Cloud Functions, phone authentication, and performance monitoring. However, one SDK that hasn‚Äôt changed much is the Firebase Realtime Database (RTDB).<p>The RTDB hasn‚Äôt received any major updates ‚Äî and not because it was a perfect API. Far from it. If you‚Äôve read about <a href=//medium.freecodecamp.org/firebase-the-great-the-meh-and-the-ugly-a07252fbcf15>Pier Bover‚Äôs experience</a>, or have used the Firebase RTDB yourself, these problems might sound familiar:<blockquote><h2>No way to query your data properly [‚Ä¶] and dumb data modelling.</h2></blockquote><p><br>So what‚Äôs next? How is Google going to solve these limitations? Instead of releasing a version 4.0 of the RTDB, which would be messy and painful for everyone, Google is using what it learned from the Firebase Realtime Database‚Äôs faults. And they‚Äôre completely redesigning and rewriting it from scratch into a new database: Cloud Firestore.<p>The RTDB isn‚Äôt going away ‚Äî that would cause a huge crisis. But going forward, Cloud Firestore will receive most of the attention and love.<p>This article is going to delve deep into Google‚Äôs long-awaited database revamp, mostly from an Android RTDB developer‚Äôs point of view. In addition, the article is intended as a replacement for hours of pouring over documentation to build a mental model of the new SDK.<h2 id=background>Background <a href=#background class=header-link>#</a></h2><p>Unless you‚Äôve just recently joined the Firebase party, you‚Äôve probably heard of the Google Cloud Platform (GCP). Except for the RTDB, all other Firebase server products, like Cloud Functions and Firebase Storage, are usually rebrands of existing GCP solutions with extra bells and whistles ‚Äî plus Firebase integration and branding.<p>However, the RTDB was ported over from the pre-Google Firebase. It turns out that the database actually used to be a chat service. They only decided to strip out the UI and turn it into an SDK after the company shifted its focus. With the never-ending swarm of chat app samples, you‚Äôd think they‚Äôre still a little bit nostalgic.<p>On the other hand, Cloud Firestore is built off GCP‚Äôs Google Cloud Datastore, a NoSQL database with near-infinite scalability and powerful querying abilities. The Firebase-branded Cloud Datastore adds the expected realtime capabilities and, of course, integration with other Firebase services such as Authentication and Cloud Functions.<p><a href=/assets/firebase/gcp-data-flowchart.jpeg><picture><source sizes="(min-width: 768px) 85vw, 100vw" srcset="/assets/resized/firebase/gcp-data-flowchart-240-min.avif 240w, /assets/resized/firebase/gcp-data-flowchart-320-min.avif 320w, /assets/resized/firebase/gcp-data-flowchart-480-min.avif 480w, /assets/resized/firebase/gcp-data-flowchart-800-min.avif 800w, /assets/resized/firebase/gcp-data-flowchart-min.avif 1280w" type=image/avif><source sizes="(min-width: 768px) 85vw, 100vw" srcset="/assets/resized/firebase/gcp-data-flowchart-240-min.jpg 240w, /assets/resized/firebase/gcp-data-flowchart-320-min.jpg 320w, /assets/resized/firebase/gcp-data-flowchart-480-min.jpg 480w, /assets/resized/firebase/gcp-data-flowchart-800-min.jpg 800w, /assets/resized/firebase/gcp-data-flowchart-min.jpg 1280w" type=image/jpeg><source sizes="(min-width: 768px) 85vw, 100vw" srcset="/assets/resized/firebase/gcp-data-flowchart-240.jpeg 240w, /assets/resized/firebase/gcp-data-flowchart-320.jpeg 320w, /assets/resized/firebase/gcp-data-flowchart-480.jpeg 480w, /assets/resized/firebase/gcp-data-flowchart-800.jpeg 800w, /assets/firebase/gcp-data-flowchart.jpeg 1280w"><img alt="GCP Data Flowchart" class="loads article-image" height=720 loading=lazy src=/assets/resized/firebase/gcp-data-flowchart-240.jpeg width=1280></picture></a><div class=text-gray><p class=caption>Pre-Firestore flow chart. You now get the best of both Firebase and Datastore!</div><p>For database fans, Cloud Datastore is a multi-region, synchronously-replicated database that uses ACID transactions. This means that once Google says your write is committed, a dinosaur-age meteor could take out a region and your data would still be safe and sound, ready to be queried.<p>Now I‚Äôm not saying we humans would fare so well‚Ä¶ but at least your data would still be rock solid! Oh, and it uses atomic clocks ‚Äî now if that isn‚Äôt cool, I don‚Äôt know what is!<p>Now that you have a basic understanding of why Google decided to create a completely new Firebase branded database and where it came from, let‚Äôs get started!<p>For the rest of this article, I‚Äôll be using examples from apps I‚Äôve built (so no chat app samples! üòÅ). Specifically, I‚Äôll be using examples from <a href=//github.com/SUPERCILEX/Robot-Scouter>Robot Scouter</a>, an app to help <a href=//www.firstinspires.org/robotics/frc>FIRST Robotics Competition</a> teams make data-driven decisions during competitions.<p>The app‚Äôs basic purpose is to allow users to collect data about other teams in units called scouts. These <strong>scouts</strong> can be based off customizable <strong>templates</strong>. Scouts and templates are composed of <strong>metrics</strong>, which are different types of data a user can collect. Templates are standalone objects, but scouts are implicitly owned by a team.<p>Individual teams and templates can be shared with other users, but the scouts will follow a team around wherever it goes since the team owns them.<h2 id=data-structures>Data structures <a href=#data-structures class=header-link>#</a></h2><p>Let‚Äôs start by looking at what the Robot Scouter data structure looked like with the RTDB. Take a deep breath, there‚Äôs a lot to scroll through:</p><noscript><pre>{
  "team-indices": {
    "uid1": {
      "teamKey1": 2521, // We sort our teams in ascending order by team number
      "teamKey2": { ... },
      "teamKey3": { ... }
    },
    "uid2": { ... },
    "uid3": { ... }
  },
  "teams": {
    "teamKey1": {
      "name": "SERT",
      "number": 2521,
      // Other fields
    },
    "teamKey2": { ... },
    "teamKey3": { ... }
  },
  "scout-indices": {
    "teamKey1": {
      "scoutKey1": 1489877223288, // We sort our scouts in descending order by creation date
      "scoutKey2": { ... },
      "scoutKey3": { ... }
    },
    "teamKey2": { ... },
    "teamKey3": { ... }
  },
  "scouts": {
    "scoutKey1": {
      "name": "Scout 1",
      "metrics": {
        // List of metrics
      }
    },
    "scoutKey2": { ... },
    "scoutKey3": { ... }
  },
  "template-indices": {
    "uid1": {
      "templateKey1": 1489877223288, // We also sort our templates in descending order by creation date
      "templateKey2": { ... },
      "templateKey3": { ... }
    },
    "uid2": { ... },
    "uid3": { ... }
  },
  "templates": {
    "templateKey1": {
      "name": "My custom template",
      "metrics": {
        // List of metrics to be used for a scout
      }
    },
    "templateKey2": { ... },
    "templateKey3": { ... }
  },
  "users": {
    "uid1": {
      "name": "Alex Saveau",
      "email": "saveau.alexandre@gmail.com",
      // Other fields
    },
    "uid2": { ... },
    "uid3": { ... }
  }
}</pre></noscript><script src=//gist.github.com/72d6f78c4281a822166c7d8f9aa827d0.js></script><div class=text-gray style=text-align:center><p class=gist-caption>Well that's a hot mess!</div><p>All we really wanted was a <code class="highlighter-rouge language-plaintext">teams</code>, <code class="highlighter-rouge language-plaintext">templates</code>, and users <code class="highlighter-rouge language-plaintext">collection</code>. Instead, we had to denormalize our data to accommodate for the RTDB‚Äôs deep-by-default queries. Remember, if we query a node with the RTDB, we also get <strong>all</strong> child nodes.<p>Now let‚Äôs take a look at the equivalent Cloud Firestore data structure:</p><noscript><pre>{
  "teams": { // Collection
    "teamId1": { // Document
      "name": "SERT",
      "number": 2521,
      "owners": { // Object within document
        "uid1": 2521, // We sort our teams in ascending order by team number
        "uid2": { ... },
        "uid3": { ... }
      },
      "scouts": { // Subcollection
        "scoutId1": { // Document
          "name": "Scout 1",
          "timestamp": 1489877223288, // We sort our scouts in descending order by creation date
          "metrics": { // Subcollection
            // List of metrics
          }
        },
        "scoutId2": { ... },
        "scoutId3": { ... }
      }
      // Other fields
    },
    "teamId2": { ... },
    "teamId3": { ... }
  },
  "templates": { // Collection
    "templateId1": { // Document
      "name": "My custom template",
      "timestamp": 1489877223288,
      "owners": { // Object within document
        "uid1": 1489877223288, // We also sort our templates in descending order by creation date
        "uid2": { ... },
        "uid3": { ... }
      },
      "metrics": { // Subcollection
        // List of metrics to be used for a scout
      }
    },
    "templateId2": { ... },
    "templateId3": { ... }
  },
  "users": { // Collection
    "uid1": { // Document
      "name": "Alex Saveau",
      "email": "saveau.alexandre@gmail.com",
      // Other fields
    },
    "uid2": { ... },
    "uid3": { ... }
  }
}</pre></noscript><script src=//gist.github.com/95813a9e0ff4854e3d51dbff75282aef.js></script><div class=text-gray style=text-align:center><p class=gist-caption>There we go, that's much better!</div><p>The Cloud Firestore data structure is easier to understand and much shorter than the RTDB structure. This is thanks to nested refs versus being forced to denormalize everything in the RTDB.<h3 id=data-structure-differences>Data structure differences <a href=#data-structure-differences class=header-link>#</a></h3><p>The first major difference you‚Äôll notice is the lack of denormalization. In the <a href=//firebase.google.com/docs/firestore/data-model>Cloud Firestore data structure</a>, we declare our <code class="highlighter-rouge language-plaintext">teams</code> ref and put each team directly inside that ref instead of flattening it out. Similarly, we‚Äôve merged the <code class="highlighter-rouge language-plaintext">template-indices</code> directly into the <code class="highlighter-rouge language-plaintext">templates</code> ref.<p>You might have also noticed that our <code class="highlighter-rouge language-plaintext">scouts</code> are now directly placed inside a team instead of being in a separate indices ref. Your first reaction might have been ‚ÄúWait, you‚Äôre going to waste all the user‚Äôs data! Don‚Äôt do that!‚Äù This is the beauty of Cloud Firestore: <strong>queries are ‚Äúshallow‚Äù by default</strong>.<p>I put the word <strong>shallow</strong> in quotes because technically, you could nest a huge amount of data in your documents. But we‚Äôll talk about why you shouldn‚Äôt do that later. Wait a sec, what‚Äôs a document? Cloud Firestore has two basic building blocks: <strong>collections</strong> and <strong>documents</strong>.<p><a href=/assets/firebase/firestore-anatomy.png><picture><source sizes="(min-width: 768px) 85vw, 100vw" srcset="/assets/resized/firebase/firestore-anatomy-240-min.avif 240w, /assets/resized/firebase/firestore-anatomy-320-min.avif 320w, /assets/resized/firebase/firestore-anatomy-480-min.avif 480w, /assets/resized/firebase/firestore-anatomy-min.avif 700w" type=image/avif><source sizes="(min-width: 768px) 85vw, 100vw" srcset="/assets/resized/firebase/firestore-anatomy-240-min.jpg 240w, /assets/resized/firebase/firestore-anatomy-320-min.jpg 320w, /assets/resized/firebase/firestore-anatomy-480-min.jpg 480w, /assets/resized/firebase/firestore-anatomy-min.jpg 700w" type=image/jpeg><source sizes="(min-width: 768px) 85vw, 100vw" srcset="/assets/resized/firebase/firestore-anatomy-240.png 240w, /assets/resized/firebase/firestore-anatomy-320.png 320w, /assets/resized/firebase/firestore-anatomy-480.png 480w, /assets/firebase/firestore-anatomy.png 700w"><img alt="Anatomy of Firestore Data" class="loads article-image" height=540 loading=lazy src=/assets/resized/firebase/firestore-anatomy-240.png width=700></picture></a><div class=text-gray><p class=caption>Cloud Firestore's fundamental building blocks</div><p>Collections in Firestore are the equivalent of a ref in the RTDB with a huge list of child nodes that each contain objects. If you scroll back up to the Firestore data structure, you‚Äôll notice that <code class="highlighter-rouge language-plaintext">teams</code>, <code class="highlighter-rouge language-plaintext">templates</code>, and <code class="highlighter-rouge language-plaintext">users</code> are all collections. They each contain a whole bunch of objects ‚Äî and in Firestore, these objects are called documents.<p>Documents would be your conventional object node in the RTDB. However, in Firestore they‚Äôre a little special: documents are explicitly owned by a collection. In the RTDB, you could put pretty much anything anywhere. Cloud Firestore brings in a little sanity and uses an alternating pattern of collections and documents which looks a little like this: <code class="highlighter-rouge language-plaintext">collection1/document1/collection2/document2/...</code>.<p>While this pattern could feel constraining at first, I‚Äôve found it helpful in forcing me to design a neatly organized data structure. You‚Äôll notice that my <code class="highlighter-rouge language-plaintext">scouts</code> collection now properly resides within a team document. I only had to split it out in the RTDB so that my users wouldn‚Äôt have to download all their scouts when looking at a team. In Cloud Firestore, teams have explicit ownership of a set of scouts without having to download them when loading the team.<h3 id=a-little-more-on-documents>A little more on documents <a href=#a-little-more-on-documents class=header-link>#</a></h3><p>In the RTDB, you had a free-flowing model with 3 core data types: booleans, strings, and numbers. Things like lists and maps were either an afterthought or just part of how you queried for data in the RTDB.<p>On the other hand, with Firestore, you have a very clear cut structure: collections contain documents, and documents contain fields and <strong>links</strong> to one or more <strong>subcollections</strong>.<p>Subcollection is just a fancy term for another list of objects owned by a document ‚Äî except you won‚Äôt get that list when querying the document. This is because documents don‚Äôt technically contain subcollections. They just link to them. Hence why we can put our <code class="highlighter-rouge language-plaintext">scouts</code> collection inside the team document ‚Äî or link to it, if you will.<p>On top of containing subcollections, documents in Firestore support a <a href=//firebase.google.com/docs/firestore/manage-data/data-types>vast array of data types</a> with more on the horizon. For now, here are the supported types:<ul><li>Boolean<li>String<li>Number<li>Raw bytes (if that‚Äôs your style üòÅ)<li>Dates and time<li>Geo points<li>Refs<li>Arrays and maps<li>Null!</ul><p>Yes, <code class="highlighter-rouge language-plaintext">null</code> is now an explicitly defined data type in Cloud Firestore. If you set a document equal to a Java object whose getter returns null, the field will still show up in the Firebase Console with the <code class="highlighter-rouge language-plaintext">null</code> data type.<p>Well ok, so what? Adding the <code class="highlighter-rouge language-plaintext">null</code> data type makes field deletion explicit. In the RTDB, setting something to <code class="highlighter-rouge language-plaintext">null</code> is the same as deleting it. But in Firestore, to delete a field you must set its value to <code class="highlighter-rouge language-plaintext">FieldValue.delete()</code>. On a similar note, <code class="highlighter-rouge language-plaintext">ServerValue.TIMESTAMP</code> has become <code class="highlighter-rouge language-plaintext">FieldValue.serverTimestamp()</code>.<p>In addition, the <code class="highlighter-rouge language-plaintext">null</code> data type sort of enables migrations. Using the <code class="highlighter-rouge language-plaintext">DocumentSnapshot#contains(‚Ä¶)</code> method, you could check to see if a field exists and do something if it doesn‚Äôt. A better strategy would be to use a Cloud Function, but that‚Äôs beyond the scope of this article.<p>You‚Äôll notice documents still support arrays and maps, but how does that work if documents can only contain fields? Remember how I said you could technically nest your data? Here‚Äôs that special case: Firestore lets you store explicitly defined arrays and maps within documents, as opposed to creating a subcollection.<p>Note: there are several <a href=//firebase.google.com/docs/firestore/quotas>limits</a> to documents in Firestore. Specifically, <strong>there is a 1MB size limit, a maximum of 20,000 properties per document, and a 500 level deep object nesting limit</strong>.<p>Properties are different from fields in that they account for all nested fields, not just the conventional root level field. In addition, as of this writing, updating a large array or map rewrites the entire array/map and will have abysmal performance on large data structures. Please use subcollections instead!<p>Because Google loves to rename things, document ‚Äúkeys‚Äù from the RTDB are now called <strong>ids</strong>. The last path segment of a collection or document is called an id, meaning <code class="highlighter-rouge language-plaintext">teams/teamId1</code> is a document with id <code class="highlighter-rouge language-plaintext">teamId1</code> under a collection with id <code class="highlighter-rouge language-plaintext">teams</code>. Nothing too groundbreaking, but it‚Äôs always nice to be on the same page when it comes to terminology.<p>Finally, since documents are one of the fundamental building blocks of Firestore, you can only get a full document. This is unlike the RTDB where you could query for as specific a field as you liked.<h2 id=storing-and-retrieving-data>Storing and retrieving data <a href=#storing-and-retrieving-data class=header-link>#</a></h2><p>Now that you have a basic understanding of Firestore‚Äôs two fundamental building blocks ‚Äî collections and documents ‚Äî it‚Äôs time to look at how we can store and then get our data.<p>The Cloud Firestore API surface is a <strong>massive</strong> improvement over the RTDB‚Äôs. So you‚Äôre unlikely to find any methods that were simply ported over (though some will look familiar).<h3 id=storing-data>Storing data <a href=#storing-data class=header-link>#</a></h3><p>The first distinction you‚Äôll notice from the RTDB is the slightly messy and spread out way of creating and updating data. Not to worry, it‚Äôll all make sense in just a bit.<p>Unlike our pets, there are no stray documents ‚Äî they must all live under a collection. This means we have two places from where we can add data: a collection to add documents, and a document to add, update, or remove fields.<p>Let‚Äôs start by looking at the simplest way to add data, though collections:</p><noscript><pre>FirebaseFirestore.getInstance().collection("teams").add(team)</pre></noscript><script src=//gist.github.com/04b889e36e662ec53180e412141b172b.js></script><div class=text-gray style=text-align:center><p class=gist-caption>Well that wasn't hard!</div><p>We‚Äôre saying that within the <code class="highlighter-rouge language-plaintext">teams</code> collection, we want to add a document with all the fields from the <code class="highlighter-rouge language-plaintext">Team</code> POJO.<p>Now let‚Äôs look at the more interesting case where we change document data:</p><noscript><pre>fun Team.addScout() {
    val scoutRef: DocumentReference = FirebaseFirestore.getInstance()
        .collection("teams")
        .document(id /* Field in Team */)
        .collection("scouts")
        .document() // Creating a document ref with a truly random id

    scoutRef.set(Scout(scoutRef.id, templateId))
    firestoreBatch {
        val metricsRef = scoutRef.collection("metrics")
        dataGatheredFromAQuery.forEach { metric ->
            set(metricsRef.document(metric.id), metric)
        }
    }
}

inline fun firestoreBatch(transaction: WriteBatch.() -> Unit): Task&lt;Void> = FirebaseFirestore.getInstance().batch().run {
    transaction()
    commit()
}</pre></noscript><script src=//gist.github.com/b0a15816a117dc109decad1bb30dd09e.js></script><div class=text-gray style=text-align:center><p class=gist-caption>Ouch, there's a lot more to cover!</div><p>The first thing to note is our <code class="highlighter-rouge language-plaintext">scoutRef</code>: it creates a scout inside our scouts collection, which in turn exists under a team document. As a URL, it would look something like this: <code class="highlighter-rouge language-plaintext">teams/teamId/scouts/newScoutId</code>.<p>The <code class="highlighter-rouge language-plaintext">document()</code> method returns a new <code class="highlighter-rouge language-plaintext">DocumentReference</code> with a random id. It‚Äôs a <strong>truly</strong> random id in the sense that it‚Äôs no longer based off of a timestamp.<p>Those familiar with the RTDB will know that the <code class="highlighter-rouge language-plaintext">push()</code> method creates a pseudo-random key using a timestamp for native temporal sorting. Since Cloud Firestore aims to move away from being a chat-oriented database, it doesn‚Äôt make sense for them to use temporal sorting as the default mechanism.<p>As such, this means you‚Äôll have to manually add a <code class="highlighter-rouge language-plaintext">timestamp</code> field when relevant. In theory, you could use the timestamp as a document id for sorting, but that reduces flexibility.<p>The <code class="highlighter-rouge language-plaintext">DocumentReference</code> contains a plethora of different ways to set and update data, from using maps and POJOs to supplying varargs. There‚Äôs a slice of pie for everyone! I‚Äôm going to focus on the POJO and specific field update methods, since those are the ones I‚Äôve found to be most useful.<p>The first method you‚Äôll notice and probably use most often is <code class="highlighter-rouge language-plaintext">set(Object)</code>. This one is fairly simple: it behaves exactly like the Java‚Äôs <code class="highlighter-rouge language-plaintext">Map#set(key, value)</code> method. If no document exists, it will create a new one. Otherwise, if a document exists, it will be overwritten.<p>However, Google also provides <a href=//firebase.google.com/docs/firestore/reference/android/SetOptions><code class="highlighter-rouge language-plaintext">SetOptions</code></a> with various merge combinations to only overwrite some fields. I‚Äôve found this to be useful when updating a user‚Äôs profile, for example. I‚Äôll set/update their <code class="highlighter-rouge language-plaintext">name</code>, <code class="highlighter-rouge language-plaintext">email</code>, and <code class="highlighter-rouge language-plaintext">photoUrl</code>, but not the <code class="highlighter-rouge language-plaintext">lastLogin</code> field, since it isn‚Äôt part of my <code class="highlighter-rouge language-plaintext">User</code> POJO.<p>If you want to ensure a document exists before performing an update, the <code class="highlighter-rouge language-plaintext">update(String, Object, Object‚Ä¶)</code> method will be the right tool for the job. In this case, we are updating a specific field with a new value. If the document doesn‚Äôt exist prior to calling the update method, the update will fail. If you‚Äôd like, you can also update multiple fields at once by alternating key/value pairs in the varargs. (I personally prefer using multiple updates in a <code class="highlighter-rouge language-plaintext">WriteBatch</code>, which I‚Äôll discuss later.)<p>What if you wanted to update a nested field inside an object? For this use case, Google provides the <code class="highlighter-rouge language-plaintext">FieldPath#of(String‚Ä¶)</code> method. Each item inside the varargs array brings you deeper inside a nested field‚Äôs path ‚Äî technically an object. For example, <code class="highlighter-rouge language-plaintext">FieldPath.of("rootField", "child")</code> updates the following field: <code class="highlighter-rouge language-plaintext">myDocument/rootField/child</code>.<p>Similarly, Firestore also supports the dot notation syntax which lets you reference that same field like so: <code class="highlighter-rouge language-plaintext">rootField.child</code>.<p>Cloud Firestore also includes an awesome new way to batch writes with the <code class="highlighter-rouge language-plaintext">WriteBatch</code> class. It‚Äôs very similar to the <code class="highlighter-rouge language-plaintext">SharedPreferences.Editor</code> you‚Äôll find on Android. You can add or update documents in the <code class="highlighter-rouge language-plaintext">WriteBatch</code> instance, but they won‚Äôt be visible to your app until you call <code class="highlighter-rouge language-plaintext">WriteBatch#commit()</code>. I‚Äôve created the standard Kotlin improvement where the batch lifecycle is managed for you ‚Äî feel free to copypasta.<p>The last important API change to note when managing data is how to delete it. Cloud Firestore has a method to delete a document ‚Äî <code class="highlighter-rouge language-plaintext">DocumentReference#delete()</code> ‚Äî but no easy way to delete an entire collection. Google provides a <a href=//firebase.google.com/docs/firestore/manage-data/delete-data#collections>code sample with documentation</a> on how to delete all documents in a collection, but they haven‚Äôt baked it into the SDK yet. This is because this method could easily fail under extreme conditions when attempting to delete thousands or even millions of documents buried in various subcollections. But Google does say they‚Äôre working on it.<p>In addition, their sample doesn‚Äôt delete subcollections either ‚Äî only documents under the collection. Google doesn‚Äôt yet have a clear solution to that problem on Android either. Still, they‚Äôre providing a CLI/NodeJS API as part of <code class="highlighter-rouge language-plaintext">firebase-tools</code> that you can use to delete all subcollections manually or from a Cloud Function.<p>In my case, I don‚Äôt let users create random collection names so I can delete all my subcollections by getting their parent document ids.<p>I‚Äôve rewritten their sample with more functionality and a cleaner API in Kotlin:</p><noscript><pre>/** Deletes all scouts for a team, including their `metrics` subcollection. */
fun Team.deleteAllScouts() {
    ref.collection("scouts").delete() // Kotlin's syntactic sugar
            .addOnSuccessListener { snapshots: List&lt;DocumentSnapshot> ->
                for (snapshot in snapshots) deleteScout(snapshot.id)
            }
}

fun Team.deleteScout(id: String) {
    val scoutDoc = ref.collection("scouts").document(id)
    scoutDoc.delete() // Native document deletion
    scoutDoc.collection("metrics").delete() // Kotlin's syntactic sugar
}

/**
 * Delete all documents in a collection. This does **not** automatically discover and delete
 * sub-collections.
 */
fun CollectionReference.delete(batchSize: Long = 100): Task&lt;List&lt;DocumentSnapshot>> = async {
    val deleted = ArrayList&lt;DocumentSnapshot>()

    var query = orderBy(FieldPath.documentId()).limit(batchSize)
    var latestDeleted = deleteQueryBatch(query)
    deleted += latestDeleted

    while (latestDeleted.size >= batchSize) {
        query = orderBy(FieldPath.documentId()).startAfter(latestDeleted.last()).limit(batchSize)
        latestDeleted = deleteQueryBatch(query)
    }

    deleted as List&lt;DocumentSnapshot>
}

/** Delete all results from a query in a single [WriteBatch]. */
@WorkerThread
private fun deleteQueryBatch(query: Query): List&lt;DocumentSnapshot> = Tasks.await(query.get()).let {
    Tasks.await(firestoreBatch {
        for (snapshot in it) delete(snapshot.reference)
    })
    it.documents
}

inline fun &lt;T> async(crossinline block: () -> T): Task&lt;T> =
        AsyncTaskExecutor.execute(Callable { block() })

object AsyncTaskExecutor : Executor {
    private val service = Executors.newCachedThreadPool()

    fun &lt;TResult> execute(callable: Callable&lt;TResult>): Task&lt;TResult> = Tasks.call(this, callable)

    override fun execute(runnable: Runnable) {
        service.submit(runnable)
    }
}</pre></noscript><script src=//gist.github.com/dad6effe480069a34e329b945ddb120a.js></script><div class=text-gray style=text-align:center><p class=gist-caption>Deleting all <code>scouts</code> and their associated metrics under a team</div><p>Whew, we‚Äôve covered most everything you‚Äôll need to know about storing data!<h3 id=retrieving-data>Retrieving data <a href=#retrieving-data class=header-link>#</a></h3><p>The first thing to note is that I‚Äôm using the word <strong>retrieving</strong> instead of reading. This is because Firestore provides two very clear-cut ways of retrieving data: either through a single read (aka a <strong>get</strong>), or through a series of reads (aka a <strong>snapshot listener</strong>).<h3 id=getting-data>Getting data <a href=#getting-data class=header-link>#</a></h3><p>Let‚Äôs start by exploring ways to read data once. In the RTDB, you had the <code class="highlighter-rouge language-plaintext">addListenerForSingleValueEvent()</code> method, but it was full of bugs and edge cases. I think Frank van Puffelen ‚Äî a Googler ‚Äî summed it up best:<blockquote><h2>The best way to solve this is to not use a single-value listener. <a href=#getting-data class=header-link>#</a></h2></blockquote><p><br>Yeah. There‚Äôs definitely a problem when you tell your own users not to use a product you‚Äôre selling.<p>Cloud Firestore completely revamps the entire data retrieval experience with better and more intuitive APIs.<p>First, a note on offline capabilities. The RTDB wasn‚Äôt designed as an offline first database ‚Äî offline capabilities were more of an afterthought since the db was ported over from pre-Google Firebase. On the other hand, Cloud Firestore isn‚Äôt exactly an offline first database since it‚Äôs also designed to be realtime. But I would consider its offline capabilities to be first class citizens along with the realtime stuff.<p>Given those improvements, offline support is enabled by default (except for web), and data is stored in a SQLite database using Android‚Äôs native APIs. I don‚Äôt know about you, but I find it more than a little ironic that a NoSQL database needs a SQL database to work.<p>For the curious, Firestore‚Äôs SQL database is named <code class="highlighter-rouge language-plaintext">firestore.$firebaseAppName.$projectId.(default)</code>. In addition, they lock it using <code class="highlighter-rouge language-plaintext">PRAGMA locking_mode = EXCLUSIVE</code> to improve performance and prevent multi-process access. If you‚Äôre really curious, here are the tables and queries I‚Äôve found so far:</p><noscript><pre>// Creating tables for v1
db.execSQL("CREATE TABLE mutation_queues (uid TEXT PRIMARY KEY, last_acknowledged_batch_id INTEGER, last_stream_token BLOB)");
db.execSQL("CREATE TABLE mutations (uid TEXT, batch_id INTEGER, mutations BLOB, PRIMARY KEY (uid, batch_id))");
db.execSQL("CREATE TABLE document_mutations (uid TEXT, path TEXT, batch_id INTEGER, PRIMARY KEY (uid, path, batch_id))");
db.execSQL("CREATE TABLE targets (target_id INTEGER PRIMARY KEY, canonical_id TEXT, snapshot_version_seconds INTEGER, snapshot_version_nanos INTEGER, resume_token BLOB, last_listen_sequence_number INTEGER,target_proto BLOB)");
db.execSQL("CREATE INDEX query_targets ON targets (canonical_id, target_id)");
db.execSQL("CREATE TABLE target_globals (highest_target_id INTEGER, highest_listen_sequence_number INTEGER)");
db.execSQL("CREATE TABLE target_documents (target_id INTEGER, path TEXT, PRIMARY KEY (target_id, path))");
db.execSQL("CREATE INDEX document_targets ON target_documents (path, target_id)");
db.execSQL("CREATE TABLE remote_documents (path TEXT PRIMARY KEY, contents BLOB)");

// Already migrating tables to v2
db.execSQL("ALTER TABLE target_globals ADD COLUMN last_remote_snapshot_version_seconds INTEGER");
db.execSQL("ALTER TABLE target_globals ADD COLUMN last_remote_snapshot_version_nanos INTEGER");
db.execSQL("UPDATE target_globals SET last_remote_snapshot_version_seconds=0, last_remote_snapshot_version_nanos=0");

// Some of the queries I found
"SELECT path FROM target_documents WHERE target_id = ?"
"SELECT target_proto FROM targets WHERE canonical_id = ?"
"SELECT m.mutations FROM document_mutations dm, mutations m WHERE dm.uid = ? AND dm.path = ? AND dm.uid = m.uid AND dm.batch_id = m.batch_id"
"INSERT INTO target_globals (highest_target_id, highest_listen_sequence_number, last_remote_snapshot_version_seconds, last_remote_snapshot_version_nanos) VALUES (?, ?, ?, ?)"
"INSERT OR IGNORE INTO target_documents (target_id, path) VALUES (?, ?)"
"INSERT OR REPLACE INTO targets (target_id, canonical_id, snapshot_version_seconds, snapshot_version_nanos, resume_token, target_proto) VALUES (?, ?, ?, ?, ?, ?)"
"DELETE FROM target_documents WHERE target_id = ?"</pre></noscript><script src=//gist.github.com/103b9b746d1e33c02f42b9d0e77023ba.js></script><div class=text-gray style=text-align:center><p class=gist-caption>The SQL behind the NoSQL</div><p>I did some more digging and found a few other things. For example, GRCP devs <a href=//github.com/grpc/grpc-java/blob/16c07ba434787f68e256fc50cece1425f421b03e/okhttp/third_party/okhttp/java/io/grpc/okhttp/internal/CipherSuite.java#L36-L357>really like enums</a>. You know what they say, ‚ÄúIf something is bad for you, do more of it!‚Äù<p><a href=/assets/firebase/minified-enums.png><picture><source sizes="(min-width: 768px) 85vw, 100vw" srcset="/assets/resized/firebase/minified-enums-240-min.avif 240w, /assets/resized/firebase/minified-enums-320-min.avif 320w, /assets/resized/firebase/minified-enums-480-min.avif 480w, /assets/resized/firebase/minified-enums-800-min.avif 800w, /assets/resized/firebase/minified-enums-min.avif 1595w" type=image/avif><source sizes="(min-width: 768px) 85vw, 100vw" srcset="/assets/resized/firebase/minified-enums-240-min.jpg 240w, /assets/resized/firebase/minified-enums-320-min.jpg 320w, /assets/resized/firebase/minified-enums-480-min.jpg 480w, /assets/resized/firebase/minified-enums-800-min.jpg 800w, /assets/resized/firebase/minified-enums-min.jpg 1595w" type=image/jpeg><source sizes="(min-width: 768px) 85vw, 100vw" srcset="/assets/resized/firebase/minified-enums-240.png 240w, /assets/resized/firebase/minified-enums-320.png 320w, /assets/resized/firebase/minified-enums-480.png 480w, /assets/resized/firebase/minified-enums-800.png 800w, /assets/firebase/minified-enums.png 1595w"><img alt="gRPC Enums" class="loads article-image" height=1788 loading=lazy src=/assets/resized/firebase/minified-enums-240.png width=1595></picture></a><div class=text-gray><p class=caption>There are 95 enums in here ‚Äî that must be some kind of record!</div><p>With that aside, let‚Äôs explore our first method: <code class="highlighter-rouge language-plaintext">DocumentReference#get()</code>. This is the simplest and most basic way to retrieve data: it replaces the RTBD‚Äôs <code class="highlighter-rouge language-plaintext">addListenerForSingleValueEvent()</code> method with several notable improvements.<p>First, it returns a <code class="highlighter-rouge language-plaintext">Task&lt;DocumentSnapshot></code>. This makes far more sense than using the same event model API as you would for snapshot listeners from the RTDB. Now, you can use all of Play Services‚Äôs lovely <code class="highlighter-rouge language-plaintext">Task</code> APIs to add your success and failure listeners. You can even attach them to an activity lifecycle if needed.<p>Second, offline support actually makes sense when using <code class="highlighter-rouge language-plaintext">get()</code>. If the device is online, you‚Äôll get the most up-to-date copy of your data directly from the server. If the device is offline and has cached data, you‚Äôll immediately get that cache. And finally, if there‚Äôs no cached data, you‚Äôll immediately get a failure event with error code <code class="highlighter-rouge language-plaintext">FirebaseFirestoreException.Code#UNAVAILABLE</code>. TLDR: you‚Äôll get the most up-to-date data that can be retrieved in the device‚Äôs current network state.<p>I‚Äôll dive into queries in just a bit, but for now, I‚Äôll just mention that the <code class="highlighter-rouge language-plaintext">Query#get()</code> method returning a <code class="highlighter-rouge language-plaintext">Task&lt;QuerySnapshot></code> is also available with the same behavior as described above.<p>In other notable news, the <code class="highlighter-rouge language-plaintext">Query#getRef()</code> method was removed to support a possible future where a query doesn‚Äôt depend on a <code class="highlighter-rouge language-plaintext">CollectionReference</code>. Just like in the RTDB, <code class="highlighter-rouge language-plaintext">CollectionReference</code> extends <code class="highlighter-rouge language-plaintext">Query</code> to support easily starting a query. But in the RTDB, you used to be able to jump back and forth between queries and refs. This is no longer the case in Firestore. I‚Äôve found this to be a mild inconvenience, but nothing too major.<h3 id=listening-for-data>Listening for data <a href=#listening-for-data class=header-link>#</a></h3><p>Of course, this is Firebase ‚Äî so we also want our sweet, sweet realtime capabilities. The API surface for queries was also completely revamped to be cleaner and clearer.<p>Let‚Äôs start by looking at how you would get all the documents in a collection.<p>Do you remember the difference between <code class="highlighter-rouge language-plaintext">addValueEventListener()</code> and <code class="highlighter-rouge language-plaintext">addChildEventListener()</code> from the RTDB? And have you ever wished you could get a bit of both worlds? Me too. Thankfully, this is exactly what Google has done with Cloud Firestore: you‚Äôll get the entire list of documents <strong>and</strong> a list of changes <strong>and</strong> possible exceptions all in one monolithic callback.<p>I‚Äôm not sure I like the combined data/exception model, but it makes sense in a Java 8 world with functional interfaces. For example, here‚Äôs a nice lambdazed callback:</p><noscript><pre>FirebaseFirestore.getInstance()
        .collection("teams")
        .addSnapshotListener { snapshot: QuerySnapshot?, e: FirebaseFirestoreException? ->
            if (e != null) {
                FirebaseCrash.report(e)
                return@addSnapshotListener
            }
            snapshot!! // The parameters follow a XOR pattern so this is perfectly safe

            // Do stuff
        }</pre></noscript><script src=//gist.github.com/14999b4fe7c85a7e237789147adcab55.js></script><div class=text-gray style=text-align:center><p class=gist-caption>Not bad, right? This is much cleaner than the RTDB callback(s).</div><p>Let‚Äôs start with the error case, since that‚Äôs what all good developers should think about first, right? üòÅ<p><code class="highlighter-rouge language-plaintext">FirebaseFirestoreException</code> is relatively simple compared to the RTDB. First, it‚Äôs actually an exception! Whaaat? An error that actually extends <code class="highlighter-rouge language-plaintext">Exception</code> ‚Äî who would have thought!? This makes crash reporting dead simple: just report the exception which includes <a href=//firebase.google.com/docs/firestore/reference/android/FirebaseFirestoreException.Code>error codes</a> and everything. It‚Äôll look nice and pretty like this:<div class="highlighter-rouge language-plaintext"><div class=highlight><pre class=highlight><code>Exception com.google.firebase.firestore.FirebaseFirestoreException: PERMISSION_DENIED: Missing or insufficient permissions.
</code></pre></div></div><p>With that aside, let‚Äôs move on to the exciting stuff: <a href=//firebase.google.com/docs/firestore/reference/android/QuerySnapshot><code class="highlighter-rouge language-plaintext">QuerySnapshot</code></a>. It contains <a href=//firebase.google.com/docs/firestore/reference/android/DocumentChange>document changes</a>, the full list of <a href=//firebase.google.com/docs/firestore/reference/android/DocumentSnapshot>documents</a>, and some other data I‚Äôll explore in just a bit.<p>I‚Äôve provided links to all the relevant classes, because I‚Äôm going to skip over those in favor of using FirebaseUI. I‚Äôll explore this in depth later when we‚Äôre putting everything together.<p>As a quick summary, you can differentiate between different update types, iterate over the <code class="highlighter-rouge language-plaintext">QuerySnapshot</code> to get each <code class="highlighter-rouge language-plaintext">DocumentSnapshot</code> in pretty Java 5 for loops, convert the entire list to a bunch of POJOs (not recommended for performance reasons, will discuss later), and convert individual documents to a POJO or access specific field information. So basically everything you‚Äôd expect from a nice API.<p>However, I do want to explore listener registration and <code class="highlighter-rouge language-plaintext">QueryListenOptions</code> ‚Äî a new way get information about your offline status.<p>Those two concepts will be easier to understand with a code sample, so here goes nothing:</p><noscript><pre>// Please don't actually use this method, it's just a nice example of how painful the listener registration API is.
// I wrote it with a case of YAGNI before I really understood the Firestore APIs‚Äîyou should
// be using `Query#get()` if you need the most up-to-date copy of your documents.
fun Query.getFromServer(): Task&lt;QuerySnapshot> = TaskCompletionSource&lt;QuerySnapshot>().apply {
    val listener = object : EventListener&lt;QuerySnapshot> {
        lateinit var registration: ListenerRegistration

        override fun onEvent(snapshot: QuerySnapshot?, e: FirebaseFirestoreException?) {
            if (e == null) {
                if (!snapshot!!.metadata.isFromCache) {
                    setResult(snapshot)
                    registration.remove()
                }
            } else {
                FirebaseCrash.report(e)
                setException(e)
                registration.remove()
            }
        }
    }

    listener.registration = addSnapshotListener(
            QueryListenOptions().includeQueryMetadataChanges(),
            listener)
}.task</pre></noscript><script src=//gist.github.com/7fe920be9b24eb818a1becab3be8c3b0.js></script><div class=text-gray style=text-align:center><p class=gist-caption>Not too pretty. üòï</div><p>The basic idea of this method is to wait until data is received directly from the server.<p>The first thing to note is listener registration ‚Äî it‚Äôs kinda painful. I‚Äôve spent some time thinking about it, and I‚Äôve come to the conclusion that Google made the right choice. It <strong>should</strong> be painful to nudge you in the right direction.<p>Ok, let‚Äôs back up a bit. In the RTDB, you‚Äôre used to removing the listener callback instance directly from the Query class. This was a nice API, but it let you do terrible things like accidentally leak your <code class="highlighter-rouge language-plaintext">Context</code>s. The new API returns a <code class="highlighter-rouge language-plaintext">ListenerRegistration</code> whose only method is <code class="highlighter-rouge language-plaintext">remove()</code> ‚Äî pretty self-explanatory.<p>This new listener registration method forces you to rethink your approach to retrieving data. Here‚Äôs a simple guide to choosing which API to use:<ol><li>If your data isn‚Äôt being displayed to the user, you should probably be using one of the <code class="highlighter-rouge language-plaintext">get()</code> methods that use the same listener registration mechanism internally as shown above. (Google‚Äôs suffering for you üòÅ)<li>If your data is tied to UI, you should use the <code class="highlighter-rouge language-plaintext">addSnapshotListener(Activity, ...)</code> variant which automatically manages lifecycle for you by unregistering in <code class="highlighter-rouge language-plaintext">Activity#onStop()</code>.<li>If your data is tied to a list like a <code class="highlighter-rouge language-plaintext">RecyclerView</code>, hold your horses ‚Äî I‚Äôm going to detail the much-improved FirebaseUI library later on, which will automatically handle nearly everything for you.<li>If you don‚Äôt fall into the above categories, then you should consider using FirebaseUI (again!) which I‚Äôll detail later (again!). Otherwise, just avert your eyes. üòú</ol><p>Ok, so the listener registration API is painful, but intentionally so to nudge you into picking the right tool for the job.<p>Now let‚Äôs take a look at the <code class="highlighter-rouge language-plaintext">QueryListenOptions</code>. Remember how I said Cloud Firestore considers offline support a first class citizen? Here‚Äôs where they address the final pain points devs experienced with the RTDB. They still don‚Äôt offer a way to customize how your data is cached, but personally, I don‚Äôt see any value in that kind of customization: the API should be smart enough to manage that stuff for me ‚Äî and it is with Firestore.<p>The first method you‚Äôll find in your listen options is called <code class="highlighter-rouge language-plaintext">includeQueryMetadataChanges()</code> and the second is called <code class="highlighter-rouge language-plaintext">includeDocumentMetadataChanges()</code>. Both of these are tied to <code class="highlighter-rouge language-plaintext">SnapshotMetadata</code>‚Äôs <code class="highlighter-rouge language-plaintext">isFromCache()</code> and <code class="highlighter-rouge language-plaintext">hasPendingWrites()</code> respectively.<p>For a given <code class="highlighter-rouge language-plaintext">QuerySnapshot</code>, <code class="highlighter-rouge language-plaintext">isFromCache()</code> will have the same value for each <code class="highlighter-rouge language-plaintext">DocumentSnapshot</code>‚Äôs metadata and for query‚Äôs metadata itself. This means you can find out if your data is up-to-date with the server either from a <code class="highlighter-rouge language-plaintext">QuerySnapshot</code> or from a <code class="highlighter-rouge language-plaintext">DocumentSnapshot</code> ‚Äî it doesn‚Äôt matter. Either the entire query is considered to be up-to-date, or not ‚Äî there‚Äôs no in-between state like the API would have you believe. In theory, one of your documents could actually be up-to-date if another active listener includes that document in its results, but Google has opted for simplicity and doesn‚Äôt surface this information in the API.<p>On the other hand, <code class="highlighter-rouge language-plaintext">hasPendingWrites()</code> can have a different value for each <code class="highlighter-rouge language-plaintext">DocumentSnapshot</code>. This is what you‚Äôd expect, and there aren‚Äôt any special edge cases or tricks.<p>To summarize:<ul><li>Use <code class="highlighter-rouge language-plaintext">includeQueryMetadataChanges()</code> if you‚Äôd like know whether a query and all its documents are up-to-date with the server.<li>Use <code class="highlighter-rouge language-plaintext">includeDocumentMetadataChanges()</code> if you‚Äôd like to know about per-document changes in pending write status.</ul><p>One last tidbit before I move on: all the <code class="highlighter-rouge language-plaintext">addSnapshotListener</code> methods are also duplicated in <code class="highlighter-rouge language-plaintext">DocumentReference</code> so you can get updates about just a single document if needed.<h3 id=querying-data>Querying data <a href=#querying-data class=header-link>#</a></h3><p>Ahhh‚Ä¶ More than 3,000 words later, we finally get into the meat of Cloud Firestore.<p>I don‚Äôt have any statistics to back this statement, but I think that by far the biggest complaint about the RTDB is the lack of proper querying abilities. Here‚Äôs another quote from Pier Bover‚Äôs article:<blockquote><h2>Really? Google is providing a data service with no searching or filtering capabilities? Yeah. Really. <a href=#querying-data class=header-link>#</a></h2></blockquote><p><br>Since Cloud Firestore is backed by GCP‚Äôs Cloud Datastore, queries are first class citizens.<p>Let‚Äôs go back to our new and improved data structure. But to save you from aggressively scrolling up for a minute, here it is reposted:</p><noscript><pre>{
  "teams": { // Collection
    "teamId1": { // Document
      "name": "SERT",
      "number": 2521,
      "owners": { // Object within document
        "uid1": 2521, // We sort our teams in ascending order by team number
        "uid2": { ... },
        "uid3": { ... }
      },
      "scouts": { // Subcollection
        "scoutId1": { // Document
          "name": "Scout 1",
          "timestamp": 1489877223288, // We sort our scouts in descending order by creation date
          "metrics": { // Subcollection
            // List of metrics
          }
        },
        "scoutId2": { ... },
        "scoutId3": { ... }
      }
      // Other fields
    },
    "teamId2": { ... },
    "teamId3": { ... }
  },
  "templates": { // Collection
    "templateId1": { // Document
      "name": "My custom template",
      "timestamp": 1489877223288,
      "owners": { // Object within document
        "uid1": 1489877223288, // We also sort our templates in descending order by creation date
        "uid2": { ... },
        "uid3": { ... }
      },
      "metrics": { // Subcollection
        // List of metrics to be used for a scout
      }
    },
    "templateId2": { ... },
    "templateId3": { ... }
  },
  "users": { // Collection
    "uid1": { // Document
      "name": "Alex Saveau",
      "email": "saveau.alexandre@gmail.com",
      // Other fields
    },
    "uid2": { ... },
    "uid3": { ... }
  }
}</pre></noscript><script src=//gist.github.com/95813a9e0ff4854e3d51dbff75282aef.js></script><p>Since we have an infinite list of teams, how do we get a specific user‚Äôs teams? In the RTDB, we would have stored the data following a pattern akin to this: <code class="highlighter-rouge language-plaintext">teams/uid1/teamKey1</code>. With Cloud Firestore, we flipflop the user‚Äôs id and the team id so that the pattern looks more like this: <code class="highlighter-rouge language-plaintext">teams/teamKey1/owners/uid1</code>.<p>Now we can query for the user‚Äôs teams like so:</p><noscript><pre>FirebaseFirestore.getInstance().collection("teams").whereEqualTo("owners.$uid", true)</pre></noscript><script src=//gist.github.com/63c398352406ae738a53b20ca60a75b4.js></script><div class=text-gray style=text-align:center><p class=gist-caption>Pretty simple, right?</div><p>We‚Äôre telling Firestore to look at the <code class="highlighter-rouge language-plaintext">owners</code> field in all documents under the <code class="highlighter-rouge language-plaintext">teams</code> collection for a document with id <code class="highlighter-rouge language-plaintext">uid</code> equal to <code class="highlighter-rouge language-plaintext">true</code>.<p>Unfortunately, this method doesn‚Äôt support ordering. So instead, we‚Äôll write the following query:</p><noscript><pre>"owners.$uid".let {
    FirebaseFirestore.getInstance().collection("teams").whereGreaterThanOrEqualTo(it, 0).orderBy(it)
}</pre></noscript><script src=//gist.github.com/87ba8e20d171c1808c39460a839e42b6.js></script><div class=text-gray style=text-align:center><p class=gist-caption>A little hacky, but it works.</div><p>This query has the advantage of supporting ordering, but it comes with similar issues to the RTDB: updating those sorting values is going to be a pain.<p>In my case, the sorting values are always static: they‚Äôre either the team number or the document creation timestamp. Because I‚Äôm never going to update those sorting values, this query works perfectly for me.<p>On the other hand, you might have different constraints ‚Äî remember, I need my data to be structured in a way that supports easily sharing teams and templates across users. If this isn‚Äôt your case, you should take a look at Google‚Äôs <a href=//firebase.google.com/docs/firestore/manage-data/structure-data>suggested structures</a> and their <a href=//firebase.google.com/docs/firestore/solutions/ >solutions to common problems</a>.<p>Since the queries you write will depend on your app‚Äôs specific constraints, I‚Äôm not going to delve into them too much. But I will point out that Cloud Firestore supports <a href=//firebase.google.com/docs/firestore/query-data/queries>compound queries</a>.<p>One last notable change from the RTDB before I move on: priorities aren‚Äôt a thing anymore. Since Firestore properly supports ordering and querying, they opted to remove the <code class="highlighter-rouge language-plaintext">.priority</code> field you could find in the RTDB from Firestore documents.<p>However, if you still want to order your documents by id for some reason, Firestore provides the <code class="highlighter-rouge language-plaintext">FieldPath#documentId()</code> method for exactly that purpose.<h2 id=security-rules>Security rules <a href=#security-rules class=header-link>#</a></h2><p>Security rules in Firestore have gotten a bit worse for wear, in my opinion. However, for those familiar with Firebase Storage, you‚Äôll feel right at home. Google has merged its database rules technology with the rest of GCP.<p>On the other hand, for those coming from a JSON world with the RTDB, Firestore‚Äôs new rules syntax is a bit convoluted. If you deploy rules in your CI build, you‚Äôll have to either edit them in the Firebase Console and then copy the rules to your local editor, or edit them in a txt file. Gross.<p>Here‚Äôs what the simplest possible set of rules looks like:</p><noscript><pre>service cloud.firestore { // Boilerplate!
  match /databases/{database}/documents { // More boilerplate.
    match /{document=**} {
      allow read, write;
    }
  }
}</pre></noscript><script src=//gist.github.com/8d3a4c19fc24a50f1fc5a6791761640b.js></script><div class=text-gray style=text-align:center><p class=gist-caption>Hmmm, boilerplate anyone?</div><p>Google actually has surprisingly good <a href=//firebase.google.com/docs/firestore/security/get-started>documentation on security rules</a> ‚Äî I‚Äôve personally been able to solve nearly all of my problems just by reading the docs. I will still go over a few gotchas from the RTDB developer‚Äôs point of view (assuming you‚Äôve at least skimmed the docs).<p>First, the <code class="highlighter-rouge language-plaintext">read</code> keyword is an array of <code class="highlighter-rouge language-plaintext">get</code> and <code class="highlighter-rouge language-plaintext">list</code>, and the <code class="highlighter-rouge language-plaintext">write</code> keyword is an array of <code class="highlighter-rouge language-plaintext">create</code>, <code class="highlighter-rouge language-plaintext">update</code>, and <code class="highlighter-rouge language-plaintext">delete</code> . Each keyword is self-explanatory except for <code class="highlighter-rouge language-plaintext">list</code> ‚Äî it applies to queries, meaning <strong>not</strong> a single ‚Äúget.‚Äù Each of these keywords can be used individually, but the <code class="highlighter-rouge language-plaintext">read</code> and <code class="highlighter-rouge language-plaintext">write</code> ones were provided for convenience.<p>On a related note, you‚Äôll usually end up splitting up your <code class="highlighter-rouge language-plaintext">write</code> keywords to allow deletion. For example, using the <code class="highlighter-rouge language-plaintext">request</code> object to check write validity fails if a user is trying to delete the data in question. In addition, if you‚Äôre checking to see if someone is an owner, you‚Äôve introduced a security flaw. Anyone can add themselves, since the new data is being checked instead of the old.<p>Here‚Äôs some sample rules to put those words into code:</p><noscript><pre>service cloud.firestore {
  match /databases/{database}/documents {
    // Incorrect solution
    match /teams/{teamId} {
      allow read: ...;
      allow write: if request.resource.data.owners[request.auth.uid] is int // Returns false on delete!
                        && isValidTeam();
    }

    // Correct solution
    match /teams/{teamId} {
      allow read: ...;
      allow create: if request.resource.data.owners[request.auth.uid] is int && isValidTeam(); // Allow new teams using the "request" object
      allow update: if isExistingOwner() && isValidTeam(); // Only the user who created the team can update it
      allow delete: if isExistingOwner(); // Pre-write owners can delete a team
    }
  }
}

function isExistingOwner() {
  return resource.data.owners[request.auth.uid] is int;
}

function isValidTeam() {
  return ...;
}</pre></noscript><script src=//gist.github.com/2d7fdb224e5452ead7484e32881673ac.js></script><div class=text-gray style=text-align:center><p class=gist-caption>Standard write configuration</div><p>There‚Äôs another major difference from the RTDB developer‚Äôs perspective: rule evaluation is shallow by default. This goes along nicely with the (sub)collection model, but requires a small shift in mindset.<p>For example, the <code class="highlighter-rouge language-plaintext">request</code> variable does <strong>not</strong> contain information about its parent document. At first, I wanted to check from a document inside a subcollection if a parent document had some field. But of course this doesn‚Äôt work, because the subcollection is just a link inside of the parent document.<p>Because rules are shallow, you have to be careful when using the double star operator (<code class="highlighter-rouge language-plaintext">variable=**</code>) since its resources won‚Äôt contain parent document information. In addition, there‚Äôs some funkiness with the variable:</p><noscript><pre>service cloud.firestore {
  match /databases/{database}/documents {
    // Incorrect solution
    match /public/{doc=**} {
      allow read;

      match /foo/{bar} {
        allow write: if doc == "foobar"; // Error! "doc" is a path object, not a string
      }
    }

    // Correct solution
    match /public/{doc} {
      allow read;

      match /foo/{bar} {
        allow read;
        allow write: if doc == "foobar"; // Correct, "doc" is now the document id
      }
    }
  }
}</pre></noscript><script src=//gist.github.com/cd9902ccaa5d448baa9c6830a26ab6fd.js></script><div class=text-gray style=text-align:center><p class=gist-caption>A little tricky at first, but easy to get used to</div><h2 id=firebaseui>FirebaseUI <a href=#firebaseui class=header-link>#</a></h2><p>Now that you have a complete understanding of Cloud Firestore‚Äôs capabilities along with its differences and improvements from the RTDB, let‚Äôs take a look at how we can put all of this together to build some UI.<p><a href=//github.com/firebase/FirebaseUI-Android>FirebaseUI</a> consists of several components including <a href=//github.com/firebase/FirebaseUI-Android/blob/master/auth/README.md>auth</a> and <a href=//github.com/firebase/FirebaseUI-Android/blob/master/storage/README.md>storage</a>, but we‚Äôll focus on the <a href=//github.com/firebase/FirebaseUI-Android/blob/master/firestore/README.md>firestore</a> module.<p>In the querying section, I mentioned several times that FirebaseUI could help us. We‚Äôll start by looking at how we can improve upon <code class="highlighter-rouge language-plaintext">QuerySnapshot</code>‚Äôs <code class="highlighter-rouge language-plaintext">toObjects()</code> method.<p>There are two main problems with using the <code class="highlighter-rouge language-plaintext">toObjects()</code> method:<ol><li>Performance is going to suck, especially with large lists. On every update your <code class="highlighter-rouge language-plaintext">EventListener</code> receives, Firestore will recreate every object ‚Äî changed or not ‚Äî all at once using reflection. Ouch.<li>There‚Äôs no customization available. For example, I like my model objects to have a <code class="highlighter-rouge language-plaintext">ref</code> field so that I can easily update them later. However, I don‚Äôt want to actually store the ref in the database because that would just be pointless duplication.</ol><p>While you might be thinking, ‚Äúwell, I‚Äôll just create a list and update it whenever new objects come in,‚Äù FirebaseUI does exactly that for you so you don‚Äôt have to write boilerplate code.<p><code class="highlighter-rouge language-plaintext">FirestoreArray</code> ‚Äî as it‚Äôs aptly named ‚Äî is an array of snapshots from Firestore converted to your POJO model objects. Its constructor takes in a Firestore <code class="highlighter-rouge language-plaintext">Query</code>, a <code class="highlighter-rouge language-plaintext">SnapshotParser&lt;T></code>, and optionally, query options. It starts listening for data whenever you add one or more <code class="highlighter-rouge language-plaintext">ChangeEventListener</code>s and will automatically stop listening when the last listener is removed.<p>The <code class="highlighter-rouge language-plaintext">ChangeEventListener</code> will notify you when each object changes, when an entire update has been processed, and when any errors occur. The <code class="highlighter-rouge language-plaintext">SnapshotParser&lt;T></code> has a single method ‚Äî <code class="highlighter-rouge language-plaintext">parseSnapshot</code> ‚Äî which is responsible for converting each <code class="highlighter-rouge language-plaintext">DocumentSnapshot</code> into your model POJO of type <code class="highlighter-rouge language-plaintext">T</code>.<p>Since <code class="highlighter-rouge language-plaintext">FirestoreArray</code> implements <code class="highlighter-rouge language-plaintext">List&lt;T></code>, this setup lets you easily listen for updates to your model objects with minimal hassle.<p>In terms of performance, <code class="highlighter-rouge language-plaintext">FirestoreArray</code> uses Android‚Äôs native <code class="highlighter-rouge language-plaintext">LruCache</code> to lazily parse objects as needed. For now, we‚Äôve set the max cache size to <code class="highlighter-rouge language-plaintext">100</code>, but if you feel you‚Äôll need a bigger (or smaller) cache size, we‚Äôd love to know your use cases in a <a href=//github.com/firebase/FirebaseUI-Android/issues/new>GitHub issue</a>.<p>Since this is Firebase<strong>UI</strong>, we let you easily map your <code class="highlighter-rouge language-plaintext">FirestoreArray</code> to a <code class="highlighter-rouge language-plaintext">RecyclerView</code> with the <code class="highlighter-rouge language-plaintext">FirestoreRecyclerAdapter</code> and its <code class="highlighter-rouge language-plaintext">FirestoreRecyclerOptions</code>.<p>There are a few interesting recycler options, notably the ability to pass in an Android Architecture Components <code class="highlighter-rouge language-plaintext">LifecycleOwner</code> with which we‚Äôll automatically manage the <code class="highlighter-rouge language-plaintext">FirestoreArray</code>‚Äôs lifecycle for you.<p>Ok, that was a lot of words. Here‚Äôs what it would look like all put together with Architecture Components while taking auth states into consideration:</p><noscript><pre>val teamsQuery get() = "owners.${uid!!}".let {
    FirebaseFirestore.getInstance().collection("teams").whereGreaterThanOrEqualTo(it, 0).orderBy(it)
}

object TeamsLiveData : LiveData&lt;ObservableSnapshotArray&lt;T>>(), FirebaseAuth.AuthStateListener {
    init {
        FirebaseAuth.getInstance().addAuthStateListener(this)
    }

    override fun onAuthStateChanged(auth: FirebaseAuth) {
        value?.removeAllListeners()
        value = if (auth.currentUser == null) null else FirestoreArray(teamsQuery) { snapshot ->
            // I'm too lazy, but this could be optimized to not use reflection
            snapshot.toObject(Team::class.java).apply { id = snapshot.id }
        }
    }
}

// In your Activity's onCreate() or your Fragment's onViewCreated()
TeamsLiveData.observe(this, Observer { snapshots ->
    adapter?.stopListening() // Clean up after ourselves
    lifecycle.removeObserver(adapter) // Prevent Architecture Components from automatically re-subscribing an adapter
    if (snapshots == null) {
        // Not signed-in, show emtpy state
    } else {
        // Signed-in, let's init our adapter
        val options = FirestoreRecyclerOptions.Builder&lt;Team>()
                .setSnapshotArray(snapshots)
                .setLifecycleOwner(this)
                .build()
        adapter = object : FirestoreRecyclerAdapter&lt;Team, TeamViewHolder>(options) {
            override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): TeamViewHolder =
                    TeamViewHolder(LayoutInflater.from(parent.context)
                            .inflate(R.layout.team_list_row_layout, parent, false))

            override fun onBindViewHolder(teamHolder: TeamViewHolder, position: Int, team: Team) {
                // Bind your views
            }
        }

        recyclerView.adapter = adapter
    }
})</pre></noscript><script src=//gist.github.com/5c4c6f217d151b23f0734e924772fa34.js></script><div class=text-gray style=text-align:center><p class=gist-caption>Automatically maps a Firestore query to a RecyclerView once the user is signed-in.</div><h2 id=other-tidbits>Other tidbits <a href=#other-tidbits class=header-link>#</a></h2><p>For web developers, Firestore comes complete with full offline support, unlike the RTDB which had‚Ä¶ nothing? Yep. Cheers to offline support as a first class citizen for all mobile platforms!<p>Also, if you‚Äôd like extra info about migrating from the RTDB to Cloud Firestore, like how to keep your data synchronized during the transition period, you‚Äôll find documentation <a href=//firebase.google.com/docs/firestore/firestore-for-rtdb>here</a>.<h2 id=wrap-up>Wrap up <a href=#wrap-up class=header-link>#</a></h2><p>I hope you‚Äôve enjoyed this deep dive into Firebase‚Äôs new database and are ready to start migrating your apps. Feel free to ask me any questions or clarifications!<p>If you‚Äôve been enjoying quotes bashing the RTDB, here‚Äôs one last quote for your viewing pleasure:<blockquote><h2>People have made [the RTDB] work for prod apps, but they are forcing a square peg into a round hole. - Eric Kryski <a href=#wrap-up class=header-link>#</a></h2></blockquote><p><br>Ouch, that burns! While the RTDB may have been an uncontrollable wildfire, Cloud Firestore is a fiercely powerful flame you can wield with purpose to <strong>build better apps</strong>!</div></div></div></div></div></div><footer class=text-defaults><small>Copyright ¬© 2018-2026 Alex Saveau</small> <small><a href=//github.com/SUPERCILEX/personal-website>Source</a> | <a href=//twitter.com/SUPERCILEX>Twitter</a> | <a href=#top>Back to top</a></small></footer>